{"/bundlers/bun":{"title":"Usage with Bun","data":{"installation#Installation":"# npm\nnpm i -D @wyw-in-js/bun\n# yarn\nyarn add --dev @wyw-in-js/bun\n# pnpm\npnpm add -D @wyw-in-js/bun\n# bun\nbun add -d @wyw-in-js/bun","configuration#Configuration":"Bun plugins are configured via the Bun.build() API:\nimport wyw from '@wyw-in-js/bun';\nawait Bun.build({\n  entrypoints: ['src/index.ts'],\n  outdir: 'dist',\n  plugins: [\n    wyw({\n      filter: /\\.[cm]?[jt]sx?$/,\n    }),\n  ],\n});","transforming-libraries-in-node_modules#Transforming libraries in node_modules":"By default, the Bun plugin skips transforming files from node_modules for performance.To transform a specific library, enable transformLibraries and narrow include/exclude:\nwyw({\n  transformLibraries: true,\n  include: [/node_modules\\\\/(?:@fluentui)\\\\//],\n});","disabling-vendor-prefixing#Disabling vendor prefixing":"Stylis adds vendor-prefixed CSS by default. To disable it (and reduce CSS size), pass prefixer: false:\nwyw({\n  prefixer: false,\n});","keeping-css-comments#Keeping CSS comments":"WyW can preserve CSS comments (for example, /*rtl:ignore*/) via keepComments.Bun currently strips CSS comments in the final extracted CSS output (including directives like /*rtl:ignore*/). Bun may keep top-level /*!...*/ license comments, but comments inside rules are dropped.\nwyw({\n  keepComments: true,\n  // or keep only matching comments:\n  // keepComments: /rtl:/,\n});"}},"/bundlers/esbuild":{"title":"Usage with esbuild","data":{"installation#Installation":"# npm\nnpm i -D @wyw-in-js/esbuild\n# yarn\nyarn add --dev @wyw-in-js/esbuild\n# pnpm\npnpm add -D @wyw-in-js/esbuild\n# bun\nbun add -d @wyw-in-js/esbuild","configuration#Configuration":"import wyw from '@wyw-in-js/esbuild';\nimport esbuild from 'esbuild';\nconst prod = process.env.NODE_ENV === 'production';\nesbuild\n  .build({\n    entryPoints: ['src/index.ts'],\n    outdir: 'dist',\n    bundle: true,\n    minify: prod,\n    plugins: [\n      wyw({\n        filter: /\\.(js|jsx|ts|tsx)$/,\n        sourceMap: prod,\n      }),\n    ],\n  })\n  .catch(() => process.exit(1));","additional-babel-transformations#Additional Babel transformations":"esbuild doesn't support chaining multiple onLoad transforms for the same file. If your project needs extra Babel plugins\nto run before WyW evaluation (for example, plugins that operate on TS/JSX), enable babelTransform:\nwyw({\n  babelTransform: true,\n  babelOptions: {\n    plugins: [\n      // your custom Babel plugins\n    ],\n  },\n});\nOrder: Babel(source) → esbuild.transform() → WyW transform.Note: babelOptions are still used by WyW when parsing/evaluating modules. With babelTransform: true, the same plugins\nmay run both before esbuild and again during WyW's internal Babel stage. Prefer idempotent plugins.This is opt-in and may impact performance, so keep filter narrow when possible.","transforming-libraries-in-node_modules#Transforming libraries in node_modules":"By default, the esbuild plugin skips transforming files from node_modules for performance.To transform a specific library, enable transformLibraries and narrow filter:\nwyw({\n  transformLibraries: true,\n  filter: /node_modules\\\\/(?:@fluentui)\\\\//,\n});","disabling-vendor-prefixing#Disabling vendor prefixing":"Stylis adds vendor-prefixed CSS by default. To disable it (and reduce CSS size), pass prefixer: false:\nwyw({\n  prefixer: false,\n});","keeping-css-comments#Keeping CSS comments":"Stylis strips CSS comments by default. To preserve them (for example, /*rtl:ignore*/), pass keepComments:\nwyw({\n  keepComments: true,\n  // or keep only matching comments:\n  // keepComments: /rtl:/,\n});\nNote: esbuild removes CSS comments when minify: true. Disable CSS minification if you need comments in the final output."}},"/bundlers":{"title":"Bundlers","data":{"":"WyW provides plugins/loaders for several bundlers and frameworks. Pick the one you use:\nBun\nesbuild\nNext.js\nParcel\nRollup\nRspack\nSvelte\nVite\nWebpack\nIf you need bundler-agnostic extraction, see Bundler-agnostic extraction."}},"/bundlers/nextjs":{"title":"Usage with Next.js","data":{"":"Next.js integration for WyW is provided via @wyw-in-js/nextjs.","installation#Installation":"# npm\nnpm i -D @wyw-in-js/nextjs\n# yarn\nyarn add --dev @wyw-in-js/nextjs\n# pnpm\npnpm add -D @wyw-in-js/nextjs\n# bun\nbun add -d @wyw-in-js/nextjs","configuration#Configuration":"// next.config.js\nconst { withWyw } = require('@wyw-in-js/nextjs');\nmodule.exports = withWyw({\n  // your Next config\n});","customizing-the-loader#Customizing the loader":"Pass loaderOptions through to @wyw-in-js/webpack-loader:\n// next.config.js\nconst { withWyw } = require('@wyw-in-js/nextjs');\nmodule.exports = withWyw(\n  {\n    reactStrictMode: true,\n  },\n  {\n    loaderOptions: {\n      // see /bundlers/webpack for common loader options\n    },\n  }\n);","disabling-vendor-prefixing#Disabling vendor prefixing":"Stylis adds vendor-prefixed CSS by default. To disable it (and reduce CSS size), pass prefixer: false:\n// next.config.js\nconst { withWyw } = require('@wyw-in-js/nextjs');\nmodule.exports = withWyw(\n  {},\n  {\n    loaderOptions: {\n      prefixer: false,\n    },\n    turbopackLoaderOptions: {\n      prefixer: false,\n    },\n  }\n);","notes#Notes":"The plugin emits styles as *.wyw-in-js.module.css so imports are allowed from any module.\nAdd **/*.wyw-in-js.module.css to your .gitignore since these files are generated.","turbopack#Turbopack":"Turbopack is the default dev bundler in modern Next.js versions. @wyw-in-js/nextjs configures WyW for Turbopack via\nturbopack.rules (webpack-style loaders).Under the hood, this runs @wyw-in-js/turbopack-loader, which:\ncalls @wyw-in-js/transform,\nwrites extracted CSS as *.wyw-in-js.module.css next to the source module,\ninjects import './*.wyw-in-js.module.css' into the transformed JS/TS output.\nTo keep WyW class names stable, selectors are wrapped in :global(...) (so Next CSS Modules does not re-hash them), and\n@keyframes names are also marked as global.","turbopack-loader-options#Turbopack loader options":"Use turbopackLoaderOptions to customize @wyw-in-js/turbopack-loader:\n// next.config.js\nconst { withWyw } = require('@wyw-in-js/nextjs');\nmodule.exports = withWyw(\n  {\n    reactStrictMode: true,\n  },\n  {\n    turbopackLoaderOptions: {\n      // Turbopack requires JSON-serializable options.\n      // Pass all function-based config via a configFile path.\n      configFile: './wyw-in-js.config.js',\n    },\n  }\n);\nIf you already have turbopack.rules for JS/TS in your config, withWyw() merges them and does not override conflicting\nrule keys.","alternatives-3-approaches#Alternatives (3 approaches)":"@wyw-in-js/nextjs (official)\nWorks in next dev (Turbopack default) and next dev --webpack.\nRequires generated *.wyw-in-js.module.css files (add them to .gitignore).\nnext-with-linaria (community)\nRepo: https://github.com/dlehmhus/next-with-linaria/\nNot maintained by WyW; may use different CSS injection semantics and extra heuristics.\nBundler-agnostic extraction (@wyw-in-js/cli)\nLets you precompile sources and extract CSS outside of any bundler integration.\nSee Bundler-agnostic extraction for details."}},"/bundlers/parcel":{"title":"Usage with Parcel","data":{"installation#Installation":"# npm\nnpm i -D @wyw-in-js/parcel-transformer\n# yarn\nyarn add --dev @wyw-in-js/parcel-transformer\n# pnpm\npnpm add -D @wyw-in-js/parcel-transformer\n# bun\nbun add -d @wyw-in-js/parcel-transformer","configuration#Configuration":"Prepend @wyw-in-js/parcel-transformer to the default JS pipeline in .parcelrc:\n{\n  \"extends\": \"@parcel/config-default\",\n  \"transformers\": {\n    \"*.{js,mjs,jsm,jsx,es6,cjs,ts,tsx}\": [\"@wyw-in-js/parcel-transformer\", \"...\"]\n  }\n}"}},"/bundlers/rollup":{"title":"Usage with Rollup","data":{"":"Compatible with Rollup v1, v2, v3, and v4.","installation#Installation":"To use WyW-in-JS with Rollup, you need to use it together with a plugin which handles CSS files, such as rollup-plugin-css-only:\n# npm\nnpm i -D rollup-plugin-css-only @wyw-in-js/rollup\n# yarn\nyarn add --dev rollup-plugin-css-only @wyw-in-js/rollup\n# pnpm\npnpm add -D rollup-plugin-css-only @wyw-in-js/rollup\n# bun\nbun add -d rollup-plugin-css-only @wyw-in-js/rollup","configuration#Configuration":"import wyw from '@wyw-in-js/rollup';\nimport css from 'rollup-plugin-css-only';\nexport default {\n  plugins: [\n    wyw({\n      sourceMap: process.env.NODE_ENV !== 'production',\n    }),\n    css({\n      output: 'styles.css',\n    }),\n  ],\n};","concurrency-tsdownrolldown#Concurrency (tsdown/rolldown)":"Some Rollup-compatible bundlers may execute plugin hooks concurrently (e.g. tsdown/rolldown). To keep evaluation deterministic, @wyw-in-js/rollup serializes transform() calls by default.If you are sure your bundler runs transforms sequentially, you can opt out:\nwyw({\n  serializeTransform: false,\n});","disabling-vendor-prefixing#Disabling vendor prefixing":"Stylis adds vendor-prefixed CSS by default. To disable it (and reduce CSS size), pass prefixer: false:\nwyw({\n  prefixer: false,\n});","keeping-css-comments#Keeping CSS comments":"Stylis strips CSS comments by default. To preserve them (for example, /*rtl:ignore*/), pass keepComments:\nwyw({\n  keepComments: true,\n  // or keep only matching comments:\n  // keepComments: /rtl:/,\n});\nNote: if your CSS pipeline minifies output, ensure the minifier keeps comments.If you are using @rollup/plugin-babel as well, ensure the wyw plugin is declared earlier in the plugins array than your babel plugin.\nimport wyw from '@wyw-in-js/rollup';\nimport css from 'rollup-plugin-css-only';\nimport babel from '@rollup/plugin-babel';\nexport default {\n  plugins: [\n    wyw({\n      sourceMap: process.env.NODE_ENV !== 'production',\n    }),\n    css({\n      output: 'styles.css',\n    }),\n    babel({}),\n    /* rest of your plugins */\n  ],\n};"}},"/bundlers/svelte":{"title":"Usage with Svelte","data":{"contents#Contents":"Svelte with Rollup\nSvelte with Webpack","rollup#Rollup":"Take a look: d964432Install rollup-plugin-css-only and update rollup.config.js\nimport svelte from 'rollup-plugin-svelte';\nimport css from 'rollup-plugin-css-only'; // for CSS bundling\nimport wyw from '@wyw-in-js/rollup';\nconst dev = process.env.NODE_ENV !== 'production';\nexport default {\n  ...\n  plugins: [\n    svelte({\n      dev,\n      // allow `plugin-css-only` to bundle with CSS generated by wyw\n      emitCss: true,\n    }),\n    wyw({\n      sourceMap: dev,\n    }),\n    css({\n      output: '<OUT_FOLDER>/bundle.css',\n    }),\n  ],\n};\nIMPORTANT: rollup-plugin-css-only generates incorrect sourcemaps (see thgh/rollup-plugin-css-only#10). Use an alternative CSS plugin such as rollup-plugin-postcss instead in the same way as above.","webpack#Webpack":"Take a look: 5ffd69dUpdate webpack.config.js with the following:\nconst prod = process.env.NODE_ENV === 'production';\nconst wywLoader = {\n  loader: '@wyw-in-js/webpack-loader',\n  options: {\n    sourceMap: !prod,\n  },\n};\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /node_modules/,\n        use: [wywLoader],\n      },\n      {\n        test: /\\.svelte$/,\n        use: [\n          wywLoader,\n          {\n            loader: 'svelte-loader',\n            options: {\n              dev: !prod,\n              emitCss: true,\n              hotReload: true,\n            },\n          },\n        ],\n      },\n      ...(CSS rules)\n    ],\n  },\n};"}},"/bundlers/webpack":{"title":"Usage with Webpack","data":{"installation#Installation":"# npm\nnpm i -D @wyw-in-js/webpack-loader\n# yarn\nyarn add --dev @wyw-in-js/webpack-loader\n# pnpm\npnpm add -D @wyw-in-js/webpack-loader\n# bun\nbun add -d @wyw-in-js/webpack-loader","configuration#Configuration":"module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js/,\n        use: [{ loader: '@wyw-in-js/webpack-loader' }],\n      },\n    ],\n  },\n};","resource-queries-raw-url-etc#Resource queries (?raw, ?url, etc.)":"If you import assets with resource queries (e.g. ./arrow.svg?svgUse), WyW-in-JS ignores ?query/#hash for file reads and extension checks.For cases where evaluated code needs a value from such imports, configure importLoaders in your WyW config (see /configuration).","disabling-vendor-prefixing#Disabling vendor prefixing":"Stylis adds vendor-prefixed CSS by default. To disable it (and reduce CSS size), pass prefixer: false:\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js/,\n        use: [\n          {\n            loader: '@wyw-in-js/webpack-loader',\n            options: {\n              prefixer: false,\n            },\n          },\n        ],\n      },\n    ],\n  },\n};","keeping-css-comments#Keeping CSS comments":"Stylis strips CSS comments by default. To preserve them (for example, /*rtl:ignore*/), pass keepComments:\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js/,\n        use: [\n          {\n            loader: '@wyw-in-js/webpack-loader',\n            options: {\n              keepComments: true,\n              // or keep only matching comments:\n              // keepComments: /rtl:/,\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\nNote: if you use a CSS minimizer in production, ensure it preserves comments."}},"/changelog":{"title":"Changelog","data":{}},"/debug/log-analyzer":{"title":"Log analyzer","data":{}},"/how-to/bundler-agnostic":{"title":"Bundler-agnostic extraction with @wyw-in-js/cli","data":{"":"If your bundler does not support WyW integration (or you want to avoid bundler-specific loader hooks), you can run WyW as\nan explicit precompile/extraction step.For a CLI options reference, see /cli.This approach:\nruns @wyw-in-js/transform outside of the bundler,\nextracts CSS into standalone .css files,\noptionally injects import/require statements into the compiled JS output.","cli-usage#CLI usage":"Install the CLI:\n# npm\nnpm i -D @wyw-in-js/cli\n# yarn\nyarn add --dev @wyw-in-js/cli\n# pnpm\npnpm add -D @wyw-in-js/cli\n# bun\nbun add -d @wyw-in-js/cli\nTypical flow:\nCompile your sources to an output directory (for example dist/).\nRun extraction for the original source files, and inject CSS imports into the compiled output:\nwyw-in-js \\\n  --config ./wyw-in-js.config.js \\\n  --source-root ./src \\\n  --out-dir ./dist/wyw-css \\\n  --insert-css-requires ./dist \\\n  --modules esnext \\\n  --transform \\\n  \"src/**/*.{ts,tsx,js,jsx}\"\nNotes:\nCLI options must be filesystem paths + plain values; use --config for advanced configuration.\nKeep generated output out of Git (for example dist/ or whatever directory you choose).\nAvoid transforming node_modules (it is slow and usually unnecessary)."}},"/":{"title":"Index","data":{}},"/stability":{"title":"Stability & Production Readiness","data":{"":"WyW-in-JS is used in production build pipelines and aims to provide a predictable upgrade path.","versioning-semver#Versioning (SemVer)":"WyW-in-JS follows SemVer for the published @wyw-in-js/* packages.\n1.0.0 is a “stable baseline” release and introduces no breaking changes compared to the pre-1.0.0 line.\n1.x is the first “stable baseline” line. Breaking changes are introduced only in 2.0.0 and higher.\nminor releases add features in a backwards-compatible way.\npatch releases are for bugfixes and small improvements.\nThe pre-1.0.0 (0.x) line existed mostly because the project evolved rapidly, despite being used in real production\nsetups.","why-stable-is-non-trivial-here#Why “stable” is non-trivial here":"WyW-in-JS does a lot of work at build time, including static analysis and evaluating parts of JavaScript to compute\nstyles and artifacts.This means it interacts with:\nunbounded user code patterns,\ndependencies with various build-time assumptions,\nbundler-specific resolution behavior.\nBecause of that, some edge cases are inevitably discovered only on specific codebases. We treat such cases as bugs and\naim to keep regressions rare, but “perfect stability across all possible JS” is not realistic for a build-time evaluator.","upgrading-safely#Upgrading safely":"Read the changelog before upgrading (especially when jumping across minor versions).\nValidate the new version on a representative project (or a small repro extracted from it).\nIf you hit instability or a major slowdown, see Troubleshooting: Stability & Performance.\nIf you hit a regression, please file an issue with:\nthe exact @wyw-in-js/* versions,\nbundler/framework + version,\na minimal reproduction (or a small repository/zip), and\nerror logs and stack traces (ideally with DEBUG=wyw-in-js:*).","support#Support":"Community support happens via GitHub issues and discussions.\nIf wyw-in-js is critical to your production workflow, consider supporting the project via GitHub Sponsors:\nhttps://github.com/sponsors/anber","runtime-requirements#Runtime requirements":"Node.js >=20.0.0 (Node 18 is EOL and not supported).\nBun >=1.0.0 (supported via @wyw-in-js/bun and for running the workspace with Bun).","roadmap-high-level#Roadmap (high level)":"2.0.0 will include breaking changes (for example: moving to an ESM-only architecture and requiring newer Node.js).\n3.0.0 is focused on performance/scalability work (moving parts of the pipeline to Rust/oxc)."}},"/bundlers/rspack":{"title":"Usage with Rspack / Rsbuild","data":{"":"Rspack-based bundlers (including Rsbuild) can use WyW-in-JS through the webpack loader compatibility layer.","installation#Installation":"# npm\nnpm i -D @wyw-in-js/webpack-loader\n# yarn\nyarn add --dev @wyw-in-js/webpack-loader\n# pnpm\npnpm add -D @wyw-in-js/webpack-loader\n# bun\nbun add -d @wyw-in-js/webpack-loader","rsbuild-configuration#Rsbuild configuration":"import { defineConfig } from '@rsbuild/core';\nimport { pluginReact } from '@rsbuild/plugin-react';\nimport { pluginBabel } from '@rsbuild/plugin-babel';\nexport default defineConfig({\n  plugins: [\n    pluginReact(),\n    pluginBabel({\n      babelLoaderOptions: (_, { addPresets }) => {\n        addPresets([['@babel/preset-react', { runtime: 'automatic' }]]);\n      },\n    }),\n  ],\n  tools: {\n    bundlerChain: (chain, { CHAIN_ID }) => {\n      chain.module\n        .rule(CHAIN_ID.RULE.JS)\n        .use(CHAIN_ID.USE.SWC)\n        .after(CHAIN_ID.USE.BABEL)\n        .loader('@wyw-in-js/webpack-loader');\n    },\n  },\n});","hmr-note#HMR note":"Some Rspack setups may rebuild the generated CSS module before the JS loader finishes updating the in-memory CSS cache, which can make style updates appear “one edit behind”.WyW-in-JS avoids this by adding an internal version query to the injected CSS import when HMR is enabled, so the CSS module is invalidated on every CSS change."}},"/bundlers/vite":{"title":"Usage with Vite","data":{"installation#Installation":"Since Vite supports Rollup plugin Since Vite provides more features and flexibility, WyW-in-JS has a separate plugin for it @wyw-in-js/vite. Vite handles CSS by itself, you don't need a css plugin.\n# npm\nnpm i -D @wyw-in-js/vite\n# yarn\nyarn add --dev @wyw-in-js/vite\n# pnpm\npnpm add -D @wyw-in-js/vite\n# bun\nbun add -d @wyw-in-js/vite","configuration#Configuration":"import { defineConfig } from 'vite';\nimport wyw from '@wyw-in-js/vite';\nexport default defineConfig(() => ({\n  // ...\n  plugins: [wyw()],\n}));","transforming-libraries-in-node_modules#Transforming libraries in node_modules":"By default, the Vite plugin skips transforming files from node_modules for performance.To transform a specific library, enable transformLibraries and narrow include/exclude:\nexport default defineConfig(() => ({\n  plugins: [\n    wyw({\n      transformLibraries: true,\n      include: [/node_modules\\\\/(?:@fluentui)\\\\//],\n    }),\n  ],\n}));","preserving-generated-css-paths#Preserving generated CSS paths":"When build.rollupOptions.output.preserveModules is enabled, older Rollup versions (used by Vite 3/4) flatten asset names\nand drop directories for WyW-generated *.wyw-in-js.css files.To preserve the original directory layout for WyW CSS assets, enable preserveCssPaths:\nexport default defineConfig(() => ({\n  build: {\n    rollupOptions: {\n      output: {\n        preserveModules: true,\n        preserveModulesRoot: 'src',\n      },\n    },\n  },\n  plugins: [wyw({ preserveCssPaths: true })],\n}));","importmetaenv-during-evaluation#import.meta.env during evaluation":"WyW-in-JS evaluates a subset of your code at build time to extract styles. When that code relies on Vite's import.meta.env.*,\nthe Vite plugin injects Vite env values into the evaluation context so the expressions behave like they do in Vite runtime.The injected object is available as __wyw_import_meta_env and includes:\nVite's MODE, BASE_URL, DEV, PROD, SSR\nvariables loaded via loadEnv() respecting envPrefix (by default VITE_)\nIf you need to override values, you can provide your own overrideContext option and set __wyw_import_meta_env explicitly.","ssr-dev-fouc-styles-after-hydration#SSR dev FOUC (styles after hydration)":"When using Vite SSR in dev mode (middlewareMode + ssrLoadModule), the server-rendered HTML may not include the\ngenerated WyW CSS. The page then renders unstyled until the client runtime loads the CSS after hydration (FOUC).To avoid this, enable ssrDevCss to make the plugin:\ncollect generated CSS in memory,\nexpose it as a virtual stylesheet (/_wyw-in-js/ssr.css by default),\ninject <link rel=\"stylesheet\"> via transformIndexHtml().\nexport default defineConfig(() => ({\n  // ...\n  plugins: [wyw({ ssrDevCss: true }), react()],\n}));\nYou can customize the URL via ssrDevCssPath:\nplugins: [wyw({ ssrDevCss: true, ssrDevCssPath: '/_wyw-in-js/ssr.css' }), react()],\nThis is dev-only and does not change production builds.Notes:\nThe served stylesheet is the raw WyW output (before Vite's CSS pipeline), so some edge cases like url(...) rewriting\nmay behave differently.\nThe <link> tag is injected on each HTML transform; CSS HMR does not “re-inject” the link on the client without a\npage reload (which is fine for avoiding initial FOUC).","disabling-vendor-prefixing#Disabling vendor prefixing":"Stylis adds vendor-prefixed CSS by default. To disable it (and reduce CSS size), pass prefixer: false:\nexport default defineConfig(() => ({\n  // ...\n  plugins: [wyw({ prefixer: false })],\n}));","keeping-css-comments#Keeping CSS comments":"Stylis strips CSS comments by default. To preserve them (for example, /*rtl:ignore*/), pass keepComments:\nexport default defineConfig(() => ({\n  // ...\n  plugins: [wyw({ keepComments: true })],\n}));\nVite also strips CSS comments during build minification by default. To keep them in the final output, disable CSS minification:\nexport default defineConfig(() => ({\n  // ...\n  build: { cssMinify: false },\n  plugins: [wyw({ keepComments: true })],\n}));\nIf you are using language features that requires a babel transform (such as typescript), ensure the proper babel presets or plugins are passed to wyw.Avoid transforming node_modules by default (performance and compatibility). If you need to transform a specific library,\nuse transformLibraries and narrow include/exclude (see above).\nimport { defineConfig } from 'vite';\nimport wyw from '@wyw-in-js/vite';\n// example to support typescript syntax:\nexport default defineConfig(() => ({\n  // ...\n  plugins: [\n    wyw({\n      include: ['**/*.{ts,tsx}'],\n      exclude: ['**/node_modules/**'],\n      babelOptions: {\n        presets: ['@babel/preset-typescript', '@babel/preset-react'],\n      },\n    }),\n  ],\n}));"}},"/cli":{"title":"CLI (@wyw-in-js/cli)","data":{"":"Use @wyw-in-js/cli to run WyW extraction as a standalone step (outside of a bundler plugin).","install#Install":"# npm\nnpm i -D @wyw-in-js/cli\n# yarn\nyarn add -D @wyw-in-js/cli\n# pnpm\npnpm add -D @wyw-in-js/cli\n# bun\nbun add -d @wyw-in-js/cli","minimal-run#Minimal run":"wyw-in-js \\\n  --source-root ./src \\\n  --out-dir ./dist/wyw-css \\\n  \"src/**/*.{ts,tsx,js,jsx}\"","injecting-css-imports-into-compiled-output#Injecting CSS imports into compiled output":"If you compile your sources into dist/, you can also append import/require statements to the compiled JS files:\nwyw-in-js \\\n  --config ./wyw-in-js.config.js \\\n  --source-root ./src \\\n  --out-dir ./dist/wyw-css \\\n  --insert-css-requires ./dist \\\n  --modules esnext \\\n  --transform \\\n  \"src/**/*.{ts,tsx,js,jsx}\"\nNotes:\n--modules commonjs inserts require(...); any other value inserts import \"...\".\n--transform controls whether the CLI uses the transformed JS output produced by WyW when updating files.","options-reference#Options (reference)":"The CLI options below are based on wyw-in-js --help.\n--out-dir, -o (required): output directory for extracted CSS files.\n--source-root, -r (required): directory containing source files passed as CLI arguments.\n--config, -c: config file path (see /configuration).\n--insert-css-requires, -i: directory containing compiled JS output to append CSS imports/requires to.\n--modules, -m (default: commonjs): controls injected statement style. Allowed values: commonjs, es2015,\nes6, esnext, native.\n--transform, -t: replace template tags with evaluated values (used when updating compiled JS output).\n--source-maps, -s: generate .map files for extracted CSS.\n--parallel, -p: run extraction in parallel.\n--ignore, -x: glob pattern to exclude files (passed to glob).\n--debug, -d: write debug output (transform events) into a directory.","performance-warnings-optional#Performance warnings (optional)":"@wyw-in-js/cli runs @wyw-in-js/transform, so you can enable the same opt-in performance diagnostics used by bundler plugins:\nWYW_WARN_DYNAMIC_IMPORTS=1: warns when import() reaches prepare stage (it will be resolved/processed during build-time evaluation even if it’s lazy at runtime).\nWYW_WARN_SLOW_IMPORTS=1: warns when preparing a specific import takes “too long” (tune threshold with WYW_WARN_SLOW_IMPORTS_MS, default: 50).\nExample:\nWYW_WARN_DYNAMIC_IMPORTS=1 WYW_WARN_SLOW_IMPORTS=1 WYW_WARN_SLOW_IMPORTS_MS=200 \\\n  wyw-in-js --config ./wyw-in-js.config.js --source-root ./src --out-dir ./dist/wyw-css \"src/**/*.{ts,tsx}\"","migration-notes-linariacli--wyw-in-jscli#Migration notes (@linaria/cli → @wyw-in-js/cli)":"The binary name is wyw-in-js.\nFor advanced settings, use a config file (--config / wyw-in-js.config.js).\n@wyw-in-js/cli runs @wyw-in-js/transform, which depends on happy-dom and enables it by default via\nfeatures.happyDOM.\nYou can disable usage of DOM emulation in your config: features: { happyDOM: false } (see\n/feature-flags). This does not remove happy-dom from your lockfile — it only prevents creating\na DOM during build-time eval."}},"/configuration":{"title":"Configuration","data":{"":"WyW-in-JS can be customized using a JavaScript, JSON or YAML file. This can be in form of:\nwyw-in-js.config.js JS file exporting the object (recommended).\nwyw-in-js property in a package.json file.\n.wyw-in-jsrc file with JSON or YAML syntax.\n.wyw-in-jsrc.json, .wyw-in-jsrc.yaml, .wyw-in-jsrc.yml, or .wyw-in-jsrc.js file.\nExample wyw-in-js.config.js:\nmodule.exports = {\n  evaluate: true,\n  displayName: false,\n};","options#Options":"evaluate: boolean (default: true):Controls static evaluation of template expressions during dependency collection. It does not disable module evaluation. If there is nothing to evaluate, WyW-in-JS skips evaluation regardless of this flag. The old behavior of evaluate: false (throwing on unsupported interpolation) is deprecated and kept only for legacy configs.\ndisplayName: boolean (default: false):Enabling this will add a display name to generated class names, e.g. .Title_abcdef instead of `.abcdef'. It is disabled by default to generate smaller CSS files.\nvariableNameConfig: \"var\" | \"dashes\" | \"raw\" (default: var):Configures how the variable will be formatted in final CSS.Possible values\nvarUse full css variable structure. This is default behavior.\nimport { styled } from '@linaria/react';\nexport const MyComponent = styled.div`\n  color: ${(props) => props.color};\n`;\nIn CSS you will see full variable declaration\n.MyComponent_m1cus5as {\n  color: var(--m1cus5as-0);\n}\ndashesRemoves var() around the variable name. It is useful when you want to control the variable on your own. For example you can set default value for CSS variable.\nimport { styled } from '@linaria/react';\nexport const Theme = styled.div`\n  --font-color: red;\n`;\nexport const MyComponent = styled.div`\n  // Returning empty string is mandatory\n  // Otherwise you will have \"undefined\" in css variable value\n  color: var(${(props) => props.color ?? ''}, var(--font-color));\n`;\nfunction App() {\n  return (\n    <Theme>\n      <MyComponent>Text with red color</MyComponent>\n      <MyComponent color=\"blue\">Text with blue color</MyComponent>\n    </Theme>\n  );\n}\nIn CSS you will see generated variable name and your default value.\n.Theme_t1cus5as {\n  --font-color: red;\n}\n.MyComponent_mc195ga {\n  color: var(--mc195ga-0, var(--font-color));\n}\nrawUse only variable name without dashes and var() wrapper.\nimport { styled } from '@linaria/react';\nexport const MyComponent = styled.div`\n  color: ${(props) => props.color};\n`;\nIn CSS you will see just the variable name. This is not valid value for css property.\n.MyComponent_mc195ga {\n  color: mc195ga-0;\n}\nYou will have to make it valid:\nexport const MyComponent = styled.div`\n  color: var(--${(props) => props.color});\n`;\nclassNameSlug: string | ((hash: string, title: string, args: ClassNameSlugVars) => string) (default: default):Using this will provide an interface to customize the output of the CSS class name. Example:\nclassNameSlug: '[title]',\nWould generate a class name such as .header instead of the default .header_absdjfsdf which includes a hash.You may also use a function to define the slug. The function will be evaluated at build time and must return a string:\nclassNameSlug: (hash, title) => `${hash}__${7 * 6}__${title}`,\nWould generate the class name .absdjfsdf__42__header.Last argument args is an object that contains following properties: title, hash, index, dir, ext, file, name. These properties\nare useful when you want to generate your own hash:\nconst sha1 = require('sha1');\nmodule.exports = {\n  classNameSlug: (hash, title, args) => sha1(`${args.name}-${title}`),\n};\nnote invalid characters will be replaced with an underscore (_).Variables\nhash: The hash of the content.\ntitle: The name of the class.\nvariableNameSlug: string | ((context: IVariableContext) => string) (default: default):Using this will provide an interface to customize the output of the CSS variable name. Example:\nvariableNameSlug: '[componentName]-[valueSlug]-[index]',\nWould generate a variable name such as --Title-absdjfsdf-0 instead of the @react/styled's default --absdjfsdf-0.You may also use a function to define the slug. The function will be evaluated at build time and must return a string:\nvariableNameSlug: (context) => `${context.valueSlug}__${context.componentName}__${context.precedingCss.match(/([\\w-]+)\\s*:\\s*$/)[1]}`,\nWould generate the variable name --absdjfsdf__Title__flex-direction.note invalid characters will be replaced with an underscore (_).Variables\ncomponentName - the displayName of the component.\ncomponentSlug - the component slug.\nindex - the index of the css variable in the current component.\nprecedingCss - the preceding part of the css for the variable, i.e. flex: 1; flex-direction: .\nprocessor - the processor used to process the tag (e.g. 'StyledProcessor' or 'AtomicStyledProcessor').\nsource - the string source of the css property value.\nunit - the unit.\nvalueSlug - the value slug.\noverrideContext: (context: Partial<vm.Context>, filename: string) => Partial<vm.Context>A custom function to override the context used to evaluate modules. This can be used to add custom globals or override the default ones.\nmodule.exports = {\n  overrideContext: (context, filename) => ({\n    ...context,\n    HighLevelAPI: () => \"I'm a high level API\",\n  }),\n};\n importOverrides: Record<string, { mock: string } | { noShake: true } | { unknown: \"allow\" | \"warn\" | \"error\" }>Overrides how imports are handled during prepare/eval stages.\nKeys:\nFile imports (raw specifier starts with .) are keyed by a canonical root-relative path of the resolved file, e.g. ./src/foo.ts.\nPackage imports are keyed by the raw specifier as written in code, e.g. react or @scope/pkg.\nKeys support minimatch patterns. Exact keys take precedence; if multiple patterns match, the most specific one wins.note ? is a minimatch wildcard. To match Vite query imports like ./icon.svg?react, escape the question mark: ./icon.svg\\\\?react.\nActions:\nEach override value is one of:\nmock: replace the resolved target for the import (raw source stays intact).\nnoShake: disable tree-shaking for this import (forces only=['*']).\nunknown: controls behavior when an import reaches eval-time Node resolver fallback (warn by default).\nExample:\nmodule.exports = {\n  importOverrides: {\n    './src/i18n/messages/en.json': { unknown: 'allow' },\n    react: { mock: './src/__mocks__/react.ts' },\n    './src/vendor/broken-module.ts': { noShake: true },\n  },\n};\nNotes:\nWhen WyW evaluates __wywPreval, it tree-shakes the module and removes import '...'; side-effect imports by default, to avoid executing unrelated runtime code in Node.js (some libraries touch document, window, etc).\nIf your evaluated modules import browser-only packages (e.g. msw/browser), evaluation can still fail in Node.js. In that case, move the browser-only initialization out of evaluated modules, or mock the import via importOverrides.\nIf your evaluated modules contain runtime-only heavy dependencies (e.g. code editors, syntax highlighters), build-time evaluation can become much slower even if those dependencies are imported lazily at runtime. In that case, mock the heavy import via importOverrides to keep evaluation fast.\nIf a module re-exports many values (e.g. a large “barrel” module like an icons index), WyW may need to re-run prepare for it multiple times as the required export set grows. If it shows up in slow-import warnings even after mocking the heavy leaf imports, add { noShake: true } for the barrel module to force only=['*'] and avoid incremental reprocessing.\nIf you need a side-effect import to run during evaluation, or you need to stub a problematic side-effect import, add an override for that import:\n{ noShake: true } keeps the import and disables tree-shaking for that dependency.\n{ mock: './path/to/mock' } keeps the import but redirects it to a mock module.\nPerformance warnings (optional):\nWYW_WARN_DYNAMIC_IMPORTS=1 prints a warning when a module being prepared for evaluation contains import() that makes it to prepare stage. Even if it’s lazy at runtime (e.g. React.lazy(() => import(...))), WyW still needs to resolve/process it during build-time evaluation. If the target module is runtime-only or heavy, mock it via importOverrides.\nWYW_WARN_SLOW_IMPORTS=1 prints a warning when preparing a specific import takes “too long”. Tune the threshold via WYW_WARN_SLOW_IMPORTS_MS (default: 50).\nExample:\nWYW_WARN_DYNAMIC_IMPORTS=1 \\\nWYW_WARN_SLOW_IMPORTS=1 \\\nWYW_WARN_SLOW_IMPORTS_MS=200 \\\n<your build command>\nExample (stub a problematic side-effect import during evaluation):\nmodule.exports = {\n  importOverrides: {\n    '@radix-ui/react-tooltip': { mock: './src/__mocks__/radix-tooltip.ts' },\n  },\n};\nExample (speed up evaluation by mocking a heavy runtime-only dependency):\nmodule.exports = {\n  importOverrides: {\n    '@uiw/react-codemirror': { mock: './src/__mocks__/uiw-react-codemirror.ts' },\n  },\n};\nExample (mock a whole group of query imports, e.g. SVGR ?react):\nmodule.exports = {\n  importOverrides: {\n    '@/icons/svg/*.svg\\\\?react': { mock: './src/__mocks__/svg-react.ts' },\n  },\n};\nimportLoaders: Record<string, \"raw\" | \"url\" | ((context) => unknown) | false>Allows handling of import resource queries (e.g. ?raw, ?url, ?svgUse) during evaluation.Notes:\nThis affects only the WyW evaluation sandbox (values returned from require() / dynamic import during build), not your bundler runtime behavior.\nIf multiple query keys are present, the first matching key is used.\nSet a loader to false to disable it.\nBuilt-in loaders:\n\"raw\": returns file contents as a string (utf-8).\n\"url\": returns a relative (POSIX) path to the resolved file from the importing file directory.\nExample:\nmodule.exports = {\n  importLoaders: {\n    // Disable defaults if you don't want them\n    // raw: false,\n    // url: false,\n    // Custom loader key\n    svgUse: (ctx) => ctx.toUrl(),\n  },\n};\nrules: EvalRule[]The set of rules that defines how the matched files will be transformed during the evaluation.\nEvalRule is an object with two fields:\ntest is a regular expression or a function (path: string) => boolean;\naction is an Evaluator function, \"ignore\" or a name of the module that exports Evaluator function as a default export.\nIf test is omitted, the rule is applicable for all the files.The last matched rule is used for transformation. If the last matched action for a file is \"ignore\" the file will be evaluated as is, so that file must not contain any js code that cannot be executed in nodejs environment (it's usually true for any lib in node_modules).If you need to compile certain modules under /node_modules/ (which can be the case in monorepo projects), it's recommended to do it on a module by module basis for faster transforms, e.g. ignore: /node_modules[\\/\\\\](?!some-module|other-module)/. Example is using Regular Expressions negative lookahead.Information about Evaluator, its default setting, and custom implementations can be found in the Transform Evaluator section.The default setup is:\nimport { shaker } from '@wyw-in-js/transform';\n[\n  {\n    action: shaker,\n  },\n  {\n    test: /[\\\\/]node_modules[\\\\/]/,\n    action: 'ignore',\n  },\n  {\n    test: (filename, code) => {\n      if (!/[\\\\/]node_modules[\\\\/]/.test(filename)) {\n        return false;\n      }\n      return /(?:^|\\*\\/|;|})\\s*(?:export|import)[\\s{]/m.test(code);\n    },\n    action: shaker,\n  },\n];\ntagResolver: (source, tag, meta) => stringA custom function to use when resolving template tags.By default, linaria APIs like css and styled must be imported directly from the package – this is because babel needs to be able to recognize the API's to do static style extraction. tagResolver allows css and styled APIs to be imported from other files too.tagResolver takes the source specifier from the import (eg. @linaria/core or ./my-local-folder/linaria), the imported tag name (eg. css), and meta:\nmeta.sourceFile — the importer file path\nmeta.resolvedSource — best-effort resolved path for source (when available)\nIt returns the full path to the related processor. If tagResolver returns null, the default tag processor will be used.For example, we can use this to map @linaria/core , @linaria/react or @linaria/atomic where we re-export the module.\n{\n  tagResolver: (source, tag, { sourceFile, resolvedSource }) => {\n    const { createRequire } = require('module');\n    const { join } = require('path');\n    const pathToLocalFile = join(__dirname, './my-local-folder/linaria.js');\n    const resolved =\n      resolvedSource ??\n      (sourceFile ? createRequire(sourceFile).resolve(source) : null);\n    if (resolved === pathToLocalFile) {\n      if (tag === 'css') {\n        return require.resolve('@linaria/core/processors/css');\n      }\n      if (tag === 'styled') {\n        return require.resolve('@linaria/react/processors/styled');\n      }\n    }\n    return null;\n  };\n}\nWe can then re-export and use linaria API's from ./my-local-folder:\n// my-file.js\nimport { css, styled } from './my-local-folder/linaria';\nexport const MyComponent = styled.div`\n  color: red;\n`;\nexport default css`\n  border: 1px solid black;\n`;\n// ./my-local-folder/core.js\nexport * from '@linaria/core';\nbabelOptions: ObjectIf you need to specify custom babel configuration, you can pass them here. These babel options will be used by Linaria when parsing and evaluating modules.\nfeatures: Record<string, FeatureFlag>A map of feature flags to enable/disable. See Feature Flags for more information.\n codeRemover: CodeRemoverOptionsAn object with two keys componentTypes and hocs. It specifies types of variables and HOCs that will be replaced\nwith an empty function before evaluation (useful to avoid executing runtime-only component/HOC code at build time).\n{\n  codeRemover: {\n    componentTypes: {\n      react: ['FC', 'FunctionComponent', 'ExoticComponent'],\n      preact: ['FunctionComponent'],\n    },\n    hocs: {\n      redux: ['connect'],\n    },\n  },\n}","wyw-in-jsbabel-preset#@wyw-in-js/babel-preset":"The preset pre-processes and evaluates the CSS. The bundler plugins use this preset under the hood. You also might want to use this preset if you import the components outside of the files handled by your bundler, such as on your server or in unit tests.To use this preset, add @wyw-in-js/babel-preset to your Babel configuration at the end of the presets list:.babelrc:\n{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\",\n+   \"@wyw-in-js\"\n  ]\n}\nThe babel preset can accept the same options supported by the configuration file, however it's recommended to use the configuration file directly."}},"/feature-flags":{"title":"Feature Flags","data":{"":"Feature flags are used to enable or disable specific features provided. The features option in the configuration allows you to control the availability of these features.","syntax-for-specifying-flags#Syntax for Specifying Flags":"true: Enables the feature for all files.\nfalse: Disables the feature for all files.\n\"glob\": Enables the feature only for files that match the specified glob pattern.\n[\"glob1\", \"glob2\"]: Enables the feature for files matching any of the specified glob patterns.\n[\"glob1\", \"!glob2\"]: Enables the feature for files matching glob1 but excludes files that match glob2.\nThe dangerousCodeRemover is a flag that is enabled by default. It is designed to enhance the static evaluation of values that are interpolated in styles and to optimize the processing of styled-wrapped components during the build stage. This optimization is crucial for maintaining a stable and fast build process. It is important to note that the dangerousCodeRemover does not impact the runtime code; it solely focuses on the code used during the build.","how-it-works#How It Works":"During the build process, WyW-in-JS statically analyzes the CSS-in-JS codebase and evaluates the styles and values that are being interpolated. The dangerousCodeRemover steps in at this stage to remove potentially unsafe code, which includes code that might interact with browser-specific APIs, make HTTP requests, or perform other runtime-specific operations. By removing such code, the evaluation becomes more reliable, predictable, and efficient.","benefits#Benefits":"Enabling the dangerousCodeRemover feature provides several benefits:\nStability: The removal of potentially unsafe code ensures that the build process remains stable. It minimizes the chances of encountering build-time errors caused by unsupported browser APIs or non-static operations.\nPerformance: Removing unnecessary code results in faster build times. The build tool can efficiently process and evaluate the styles and components without unnecessary overhead, leading to quicker development cycles.","fine-tuning-the-removal#Fine-Tuning the Removal":"While the dangerousCodeRemover is highly effective at optimizing the build process, there may be cases where it becomes overly aggressive and removes code that is actually required for your specific use case. In such situations, you have the flexibility to fine-tune the behavior of the remover.By leveraging the features option in the configuration, you can selectively disable the dangerousCodeRemover for specific files. This allows you to preserve valuable code that may not be safely evaluated during the build process.","example#Example":"Suppose you have a file named specialComponent.js that contains code that should not be deleted. By adding the following entry to your features configuration:\n{\n  features: {\n    dangerousCodeRemover: [\"**/*\", \"!**/specialComponent.js\"],\n  },\n}\nYou are instructing WyW-in-JS to exclude the specialComponent.js file from the removal process. As a result, any code within this file that would have been removed by the dangerousCodeRemover will be retained in the build output.The globalCache is enabled by default. WyW-in-JS uses two levels of caching to improve the performance of the build process. The first level is used to cache transformation and evaluation results for each transform call, usually a single call of Webpack's loader or Vite's transform hook. The second level is used to cache the results of the entire build process. The globalCache feature controls the second level of caching. Turning off this feature will result in a slower build process but decreased memory usage.The happyDOM is enabled by default. This feature enables usage of https://github.com/capricorn86/happy-dom to emulate a browser environment during the build process. Typically, the dangerousCodeRemover feature should remove all browser-related code. However, some libraries may still contain browser-specific code that cannot be statically evaluated. In such cases, the happyDOM feature can be used to emulate a browser environment during the build process. This allows WyW-in-JS to evaluate the code without encountering errors caused by missing browser APIs.","nodejs-note#Node.js note":"As of happy-dom@20, the package is ESM-only. WyW-in-JS is currently published as CJS, so on Node versions where\nrequire() cannot load ESM (for example Node 20/22) WyW-in-JS will skip DOM emulation and print a one-time warning.\nTo silence the warning (and make the behavior explicit): features: { happyDOM: false }.\nFor “real” DOM emulation in Node 20+, WyW-in-JS needs an ESM-only eval architecture (planned for v2.0.0), or a runtime\nthat supports require(ESM) (Node 24+).\nThe softErrors is disabled by default. It is designed to provide a more lenient evaluation of styles and values that are interpolated in styles. This flag is useful for debugging and prevents the build from failing even if some files cannot be processed with WyW-in-JS.The useBabelConfigs feature is enabled by default. If it is enabled, WyW-in-JS will try to resolve the .babelrc file for each processed file. Otherwise, it will use the default Babel configuration from babelOptions in the configuration.Please note that the default value of useBabelConfigs will be changed to false in the next major release.The useWeakRefInEval feature is enabled by default. With it on, WyW-in-JS wraps evaluated modules in WeakRef to reduce memory usage during long-running builds. Garbage collection can reclaim these weak references in some environments, which may surface as EvalError: Module X is disposed when a disposed module is accessed again. If you encounter that error pattern, disable this flag to keep strong references (at the cost of higher memory usage).See: callstack/linaria#1352.","disable-example#Disable example":"{\n  features: {\n    useWeakRefInEval: false,\n  },\n}"}},"/how-it-works":{"title":"How it works?","data":{"":"wyw-in-js creates an entrypoint for each file to process, and transforms this entrypoint by running the workflow action.","entrypoint#Entrypoint":"We runs the worlflow action with actionRunner and actionsCache for better performance by avoiding running the same action twice. A workflow contains the following nested actions:\nworkflow\n├── processEntrypoint\n│   ├── explodeReexports\n│   │   ├── resolveImports\n│   │   └── getExports\n│   │       └── resolveImports\n│   └── transform\n│       ├── resolveImports\n│       └── processImports\n├── evalFile\n├── collect\n└── extract","workflow-action#Workflow Action":"The entry point for file processing. Sequentially calls processEntrypoint, evalFile, collect, and extract. Returns the result of transforming the source code as well as all artifacts obtained from code execution.","input#Input":"import { css } from '@foooo/processor'; /* Your processor */\nimport { getColor } from './get-color';\nexport const c1 = css`\n  background-color: ${getColor('hawk')};\n  color: ${({ theme }) => theme.palette.primary.main};\n  font-size: ${({ theme }) => theme.size.font.h1};\n`;\nexport const c2 = css(({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n}));\n/* usually defined in your processor, will be used when we're building the processor */\nexport const theme = {\n  palette: {\n    primary: {\n      main: 'red',\n    },\n    error: {\n      main: 'orange',\n    },\n  },\n  size: {\n    font: {\n      h1: '3rem',\n      h2: '2.2rem',\n    },\n  },\n};\n// ./get-color.js\nexport const getColor = (variant) => {\n  if (variant === 'hawk') {\n    return 'pink';\n  }\n  if (variant === 'wild') {\n    return 'purple';\n  }\n  if (variant === 'king') {\n    return 'green';\n  }\n  return 'white';\n};","output#Output":"The output can be different depending on the implementation of your processor!\nconst c1 = 'abcd';\nconst c2 = 'wxyz';\n.abcd {\n  background-color: pink;\n  color: red;\n  font-size: 3rem;\n}\n.wxyz {\n  background-color: purple;\n  color: orange;\n  font-size: 2.2rem;\n}","processentrypoint-action#ProcessEntrypoint Action":"The first stage of processing an entrypoint. This stage is responsible for:\nscheduling the explodeReexports action\nscheduling the transform action\nrescheduling itself if the entrypoint is superseded","explodereexports-action#ExplodeReexports Action":"Replaces wildcard reexports with named reexports. Recursively emits getExports for each reexported module, and replaces wildcard with resolved named.","input-1#Input":"export * from './foo'; /* wildcard reexports */\n// ./foo.js\nexport const foo1 = 'foo1';\nexport const foo2 = 'foo2';\nexport const foo3 = 'foo3';","output-1#Output":"export { foo1, foo2, foo3 } from './foo';","resolveimports-action#ResolveImports Action":"Resolves specified imports with a provided resolver.","getexports-action#GetExports Action":"Collects exports and re-exports. Recursively emits getExports for each reexported module.\n// index.js\nexport * from 'a'; /* wildcard re-export, emit getExports for 'a' */\n// a.js\nexport * from 'b'; /* wildcard re-export, emit getExports for 'b' */\n// b.js\nexport * from 'c'; /* wildcard re-export, emit getExports for 'c' */\n// c.js\nexport const c = 'c';","transform-action#Transform Action":"Prepares the code for evaluation. This includes removing dead and potentially unsafe code. Emits resolveImports and processImports events.","transform-preeval#Transform Preeval":"Finds the defined processors along with their usages.\nimport { /* defined processor */ css } from '@foooo/processor';\nimport { getColor } from './get-color';\nexport const c1 = /* first usage */ css`\n  background-color: ${getColor('hawk')};\n  color: ${({ theme }) => theme.palette.primary.main};\n  font-size: ${({ theme }) => theme.size.font.h1};\n`;\nexport const c2 = /* second usage */ css(({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n}));\nAfter all usages are found, we extract the expression for each usage. The extracted expressions _exp, _exp2, _exp3 and _exp4 will be inserted as close as possible before its usage.\nimport { css } from '@foooo/processor';\nimport { getColor } from './get-color';\nconst _exp = () => getColor('hawk');\nconst _exp2 = () => ({ theme }) => theme.palette.primary.main;\nconst _exp3 = () => ({ theme }) => theme.size.font.h1;\nexport const c1 = css`\n  background-color: ${getColor('hawk')};\n  color: ${({ theme }) => theme.palette.primary.main};\n  font-size: ${({ theme }) => theme.size.font.h1};\n`;\nconst _exp4 = () => ({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n});\nexport const c2 = css(({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n}));\nEach usage requires one processor instance for processing. In this case, we have two processor instance.Assume the first css processor has className = 'abcd' and dependencies = [_exp, _exp2, _exp3], second css processor has className = 'wxyz' and dependencies = [_exp4]. After the preeval stage:\nimport { css } from '@foooo/processor';\nimport { getColor } from './get-color';\nconst _exp = () => getColor('hawk');\nconst _exp2 = () => ({ theme }) => theme.palette.primary.main;\nconst _exp3 = () => ({ theme }) => theme.size.font.h1;\nexport const c1 = 'abcd'; /* do evaltime replacement */\nconst _exp4 = () => ({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n});\nexport const c2 = 'wxyz'; /* do evaltime replacement */\nexport const __wywPreval = { /* collect all dependencies in this object */\n  _exp: _exp,\n  _exp2: _exp2,\n  _exp3: _exp3,\n  _exp4: _exp4\n};","transform-evaluator#Transform Evaluator":"Finds all irrelevant code and cuts it out of the file. We use the shaker plugin by default. For the root entrypoint, we only care about the __wywPreval named export. For child entrypoints like the one for get-color.js in our example, all its code will be shaked out except for the getColor named export and its dependencies.Note about side-effect imports: during __wywPreval evaluation WyW may drop import '...'; side-effect imports from the eval bundle, to avoid executing unrelated runtime code in Node.js. If you rely on a side-effect import at eval time, use importOverrides to keep it (noShake) or replace it with a mock (mock).","processimports-action#ProcessImports Action":"Creates new entrypoints and emits processEntrypoint for each resolved import. In our example, we create a child entrypoint for the get-color module to process getColor.\nimport { css } from '@foooo/processor';\nimport { getColor } from './get-color'; /* child entrypoint with only=['getColor'] */\nconst _exp = () => getColor('hawk');\n// ...","evalfile-action#EvalFile Action":"Executes the code prepared in previous steps, the processEntrypoint action, within the current Entrypoint. Returns all exports that were requested in only.In this step, we create Module for each entrypoint and evaluate each module recursively with node:vm. After all modules are evaluated, we execute the extracted expressions _exp, _exp2, _exp3 and _exp4 which are extracted in Transform Preeval step.\nconst _exp = () => getColor('hawk');\nconst _exp2 = () => ({ theme }) => theme.palette.primary.main;\nconst _exp3 = () => ({ theme }) => theme.size.font.h1;\nconst _exp4 = () => ({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n});\nNow we have a valueCache map for building our processor instances of this entrypoint in next step.\nconst valueCache = new Map([\n  ['_exp', 'pink'],\n  ['_exp2', [Function]], /* ({ theme }) => theme.palette.primary.main */\n  ['_exp3', [Function]], /* ({ theme }) => theme.size.font.h1 */\n  ['_exp4', [Function]], /* ({ thene }) => ({ backgroundColor: getColor('wild'), ... }) */\n])","collect-action#Collect Action":"Builds and does runtime replacement for each processor. Removes __wywPreval object and all related code.Collect action calls processor.build with valueCache as the argument. You can decide how to build the artifacts. Here is a simple example:\nexport default class CssProcessor extends BaseProcessor {\n  // ...\n  build(values: Map<string, unknown>) {\n    let cssText = '';\n    const props = { theme };\n    if (this.callParam[0] === 'template') {\n      this.callParam[1].forEach((item: any) => {\n        if ('kind' in item) {\n          const evaluatedValue = values.get(item.ex.name);\n          cssText +=\n            typeof evaluatedValue === 'function'\n              ? evaluatedValue(props)\n              : evaluatedValue;\n        } else {\n          cssText += item.value.cooked;\n        }\n      });\n    } else if (this.callParam[0] === 'call') {\n      const evaluatedValue = values.get(this.callParam[1].ex.name) as Function;\n      const obj = evaluatedValue(props);\n      cssText += '\\n';\n      Object.entries(obj).forEach(([key, value]) => {\n        cssText += `  ${toKebabCase(key)}: ${value};\\n`;\n      });\n    }\n    this.artifacts.push([\n      'css',\n      [\n        /* Rules */\n        {\n          [this.adSelector]: {\n            className: this.className,\n            cssText,\n            // ...\n          },\n        },\n        /* Replacements */\n        [\n          // ...\n        ],\n      ],\n    ]);\n  }\n  // ...\n}\nThe artifacts of our first processor:\n[\n  'css',\n  {\n    '.abcd': {\n      className: 'abcd',\n      cssText: '\\n  background-color: pink;\\n  color: red;\\n  font-size: 3rem;\\n',\n      // ...\n    },\n  },\n  [\n    // ...\n  ],\n];\nThe second processor:\n[\n  'css',\n  {\n    '.wxyz': {\n      className: 'wxyz',\n      cssText: '\\n  background-color: purple;\\n  color: orange;\\n  font-size: 2.2rem;\\n',\n      // ...\n    },\n  },\n  [\n    // ...\n  ],\n];\nAnd after the code removal, our remaining code becomes:\nconst c1 = 'abcd';\nconst c2 = 'wxyz';","extract-action#Extract Action":"Extracts artifacts (e.g. CSS) from processors."}},"/how-to/custom-tagged-template":{"title":"Creating Custom Tagged Template Processors","data":{"":"In the wyw-in-js toolkit, you can create custom processors for handling tagged templates. This guide will walk you through the process of creating custom tagged template processors.","overview#Overview":"A tagged template processor is a class that extends the TaggedTemplateProcessor class from the @wyw-in-js/processor-utils package. This class provides a set of methods and properties that you can override to customize the behavior of the processor.","creating-a-processor#Creating a Processor":"To create a processor, you need to define a class that extends TaggedTemplateProcessor. The constructor of your class should call the super method with the appropriate parameters.\nimport { TaggedTemplateProcessor } from '@wyw-in-js/processor-utils';\nexport default class MyProcessor extends TaggedTemplateProcessor {\n  constructor(params: Params, ...args: TailProcessorParams) {\n    super(params, ...args);\n  }\n}\nThe Params type is an array of Param types, which represent the different ways a custom processor can be called. Each Param type corresponds to a different call pattern:\nCalleeParam: This represents a call where the processor is directly invoked with a template literal, like css``. The first element of the array is the string 'callee', and the second element is an Identifier or MemberExpression, which represents the processor being called (e.g., css).\nCallParam: This represents a call where the processor is invoked with a function call, like styled(SomeTag)``. The first element of the array is the string 'call', and the rest of the elements are ExpressionValues, which represent the arguments passed to the function call.\nMemberParam: This represents a call where the processor is invoked on a member, like styled.div``. The first element of the array is the string 'member', and the second element is a string, which represents the member being accessed (e.g., 'div').\nTemplateParam: This represents a call where the processor is invoked with a template literal, like styled``. The first element of the array is the string 'template', and the second element is an array of TemplateElements or ExpressionValues, which represent the contents of the template literal.\nIn summary, the Params type is used to capture the different ways a custom processor can be invoked, and the specific arguments or members used in the invocation.The styled.div call with a template literal color: red would be represented in the Params type as follows:\nconst params: Params = [\n  ['callee', { /* Identifier or MemberExpression representing 'styled' */ }],\n  ['member', 'div'],\n  ['template', [\n    { /* TemplateElement representing 'color: red' */ }\n  ]]\n];\nIn this example:\nThe first element of the Params array is a CalleeParam representing the styled function.\nThe second element is a MemberParam representing the div member of the styled object.\nThe third element is a TemplateParam representing the template literal color: red.\nThe actual Identifier, MemberExpression, and TemplateElement instances would be generated by a parser like Babel when parsing the source code.","isvalidparams#isValidParams":"The isValidParams function is a type guard that checks if the provided params array matches the structure defined by the constraints array. It returns a boolean indicating whether the params array is valid according to the constraints.The constraints array is an array of ParamConstraint types, which can be a ParamName (i.e., 'callee', 'call', 'member', 'template'), an array of ParamName, or a wildcard '*'. The '...' in the constraints array indicates that any number of any type of params can follow.The function iterates over the params and constraints arrays simultaneously. If it encounters a '...' in the constraints, it immediately returns true, as '...' allows any number of any params. If it encounters a '*', it checks if the corresponding param is defined. If it is not, it returns false. If the constraint is an array, it checks if the param's type is in the array. If it is not, it returns false. If the constraint is a ParamName, it checks if the param's type matches the ParamName. If it does not, it returns false.If the function iterates over all the params and constraints without returning false, it returns true, indicating that the params array is valid according to the constraints.","overriding-methods#Overriding Methods":"The TaggedTemplateProcessor class provides several methods that you can override to customize the behavior of your processor.","get-asselector#get asSelector()":"This getter should return a string that represents the CSS selector for the styles defined in the tagged template.","get-value#get value()":"This getter should return an Expression that represents the value of the tagged template. This value will replace the tagged template at runtime.For simple cases like css, it is just a string literal with a class name. For styled, it is an object with some metadata, such as the class name and information about extending.Here is an example of how the value getter might be implemented in a class that extends TaggedTemplateProcessor:\npublic override get value(): ObjectExpression {\n  const t = this.astService;\n  return t.objectExpression([\n    t.objectProperty(\n      t.stringLiteral('className'),\n      t.stringLiteral(this.className)\n    ),\n    t.objectProperty(\n      t.stringLiteral('extends'),\n      this.extendsNode\n        ? t.callExpression(t.identifier(this.extendsNode), [])\n        : t.nullLiteral()\n    ),\n  ]);\n}\nIn this example, the value getter returns an ObjectExpression that includes the class name and information about extending. The extendsNode is a hypothetical property that represents the node that the current node extends. If extendsNode is not defined, a nullLiteral is returned.","addinterpolationnode-expression-precedingcss-string-source-string-unit--#addInterpolation(node: Expression, precedingCss: string, source: string, unit = '')":"This method is called when an interpolation is found in the tagged template. It should return a string that represents the identifier of the interpolation.","doevaltimereplacement#doEvaltimeReplacement()":"This method is called during the evaluation phase. It should replace the tagged template with the appropriate value.","doruntimereplacement#doRuntimeReplacement()":"This method is called during the runtime phase. It should replace the tagged template with the appropriate value.","extractrulesvaluecache-valuecache-csstext-string-loc-sourcelocation--null#extractRules(valueCache: ValueCache, cssText: string, loc?: SourceLocation | null)":"This method is called to extract the CSS rules from the tagged template. It should return an object that represents the CSS rules.","tostring#toString()":"This method should return a string that represents the source code of the tagged template.","example#Example":"Here is an example of a custom processor that handles styled tagged templates:\nimport { TaggedTemplateProcessor, validateParams } from '@wyw-in-js/processor-utils';\nimport type { Params, TailProcessorParams } from '@wyw-in-js/processor-utils';\nexport default class StyledProcessor extends TaggedTemplateProcessor {\n  constructor(params: Params, ...args: TailProcessorParams) {\n    validateParams(params, ['callee', '*', '...'], TaggedTemplateProcessor.SKIP);\n    super(params, ...args);\n  }\n  public override get asSelector(): string {\n    return `.${this.className}`;\n  }\n  // ... other methods\n}\nIn this example, the StyledProcessor class extends TaggedTemplateProcessor and overrides several methods to handle styled tagged templates. The asSelector getter returns a CSS class selector based on the className property of the processor.Please refer to the css.ts and styled.ts files for more detailed examples of custom processors."}},"/troubleshooting":{"title":"Troubleshooting: Stability & Performance","data":{"":"WyW runs part of your code at build time to extract styles. When something becomes unstable or slow, it usually means\nWyW had to execute or traverse code that was meant to run only at runtime.This page focuses on the most common “gotchas” and the practical workarounds.","quick-checklist#Quick checklist":"When you hit a crash or a sudden slowdown:\nConfirm the problem is in WyW’s build-time pipeline (not runtime): does it reproduce in a fresh build?\nTurn on debug logs: DEBUG=wyw-in-js:*.\nTurn on optional performance hints:\nWYW_WARN_DYNAMIC_IMPORTS=1 (warns when import() makes it into the eval bundle),\nWYW_WARN_SLOW_IMPORTS=1 (warns when preparing a single import takes “too long”),\nWYW_WARN_SLOW_IMPORTS_MS=200 (raise/lower threshold).\nIf you generated WyW debug logs (actions.jsonl, dependencies.jsonl, entrypoints.jsonl), inspect them with the\nlog analyzer.\nIf logs mention Node resolution fallback, use importOverrides with { unknown:\n\"error\" } temporarily to make the first unresolved import fail fast (and show you the exact specifier).","pitfall-1-side-effects-and-extra-runtime-code-in-style-modules#Pitfall 1: Side effects (and extra runtime code) in style modules":"","why-this-is-a-bottleneck#Why this is a bottleneck":"WyW evaluates modules (or parts of them) in Node.js. Top-level side effects are risky because they may:\nrely on browser globals (document, window, HTMLElement),\ninitialize singletons (event listeners, global registries),\nperform I/O or start timers,\npull in large amounts of runtime-only code that is irrelevant for style extraction.\nWyW’s shaker tries to keep the eval bundle minimal, but it cannot always prove that a piece of code is irrelevant.","typical-symptoms#Typical symptoms":"ReferenceError: document is not defined during build.\nBuild hanging or spending minutes in “prepare/eval” even though the runtime code is lazy.\nA lot of repeated “processing” logs for the same modules.","how-to-fix-it#How to fix it":"Keep style modules as “pure” as possible:\nAvoid top-level initialization near styled/css usage.\nMove browser-only code into runtime entrypoints (or into functions that are called only at runtime).\nIf a dependency is needed at runtime but problematic at build time, mock it during evaluation:\n// wyw-in-js.config.js\nmodule.exports = {\n  importOverrides: {\n    'some-browser-only-lib': { mock: './src/__mocks__/some-browser-only-lib.ts' },\n  },\n};\nIf you actually need a side-effect import to run during evaluation (rare), keep it explicitly:\nmodule.exports = {\n  importOverrides: {\n    './src/polyfills.ts': { noShake: true },\n  },\n};","pitfall-2-heavy-arguments-to-wyw-tags-styledsomecomponent#Pitfall 2: Heavy arguments to WyW tags (styled(SomeComponent))":"","why-this-is-a-bottleneck-1#Why this is a bottleneck":"When you pass a value into a tag (e.g. styled(SomeComponent)), WyW often has to resolve that value at build time to\nproduce metadata. If SomeComponent comes from a heavy module, the evaluation graph becomes heavy too.The most common sources of accidental heaviness:\nthird‑party components with large dependency trees (editors, charts, syntax highlighters),\ncomponents wrapped in HOCs (because the HOC itself is executed to compute metadata),\n“barrel” imports that pull in many re‑exports.","typical-symptoms-1#Typical symptoms":"The build becomes much slower after introducing styled(SomeComponent) (even if the component is rendered lazily at\nruntime).\nErrors during evaluation coming from the dependency tree of the component (DOM assumptions, global state).","how-to-fix-it-1#How to fix it":"Prefer styling DOM tags (or tiny local components) and render heavy components inside:\nimport { styled } from '@linaria/react';\nimport { CodeEditor } from './code-editor';\nexport const EditorShell = styled.div`\n  border: 1px solid #ddd;\n`;\nexport function Editor(props: unknown) {\n  return (\n    <EditorShell>\n      <CodeEditor {...props} />\n    </EditorShell>\n  );\n}\nBe careful with HOC-wrapped components:\nimport { styled } from '@linaria/react';\nimport { withTracking } from './with-tracking';\nimport { Button } from './button';\nconst TrackedButton = withTracking(Button);\nexport const StyledButton = styled(TrackedButton)`\n  padding: 8px 12px;\n`;\nEven if withTracking has no import-time side effects, WyW still needs to execute withTracking(Button) to compute tag\nmetadata. That means the HOC code (and its dependency tree) can run during build-time extraction.Recommended approach: list “regular” HOCs in codeRemover, so WyW replaces them with a\nno-op wrapper during evaluation. This is safe as long as the HOC does not participate in WyW metadata (which is true for\nmost third‑party HOCs).\n// wyw-in-js.config.js\nmodule.exports = {\n  codeRemover: {\n    hocs: {\n      app: ['withTracking'],\n      redux: ['connect'],\n      mobx: ['observer'],\n    },\n  },\n};\nIf you must style a heavy third‑party component directly, mock it during evaluation:\nmodule.exports = {\n  importOverrides: {\n    '@some/editor': { mock: './src/__mocks__/some-editor.ts' },\n  },\n};\nNote: if you use displayName-based naming (for example displayName: true or a slug function depending on\ncomponentName), mocking a component can change generated class names. Prefer stable slugs (or disable displayName) if\nyou want output to remain identical.","pitfall-3-barrel-modules-and-re-exports-export-#Pitfall 3: “Barrel” modules and re-exports (export *)":"","why-this-is-a-bottleneck-2#Why this is a bottleneck":"Barrel modules (export * from ...) can be convenient, but they often:\npull in a large dependency surface (even when you import one symbol),\nmake it harder for the shaker to isolate a small set of exports,\ncause incremental “only” expansion (a module may be prepared again when another export becomes required).","typical-symptoms-2#Typical symptoms":"Slow import warnings point to an index file (icons, design-system entrypoint, components/index.ts).\nThe same barrel is processed multiple times during one build.","how-to-fix-it-2#How to fix it":"Prefer importing from leaf modules in style files:\n// Prefer this:\nimport { Dialog } from '@scope/ui-dialog';\n// Instead of this:\nimport { Dialog } from '@scope/ui';\nThe same applies to WyW tags and helpers. Avoid importing styled/css (or your custom tags) from a “kitchen sink”\nentrypoint that re-exports everything:\n// Prefer a direct tag import:\nimport { styled } from '@linaria/react';\n// Instead of a wide barrel:\nimport { styled } from '@scope/ui';\nMock heavy leaf imports, then (if needed) mark the barrel as noShake to avoid repeated incremental passes:\nmodule.exports = {\n  importOverrides: {\n    '@scope/ui-dialog': { mock: './src/__mocks__/ui-dialog.ts' },\n    '@scope/ui': { noShake: true },\n  },\n};\nThis is a trade‑off: noShake can be faster for “reprocessed many times” barrels, but it also makes the eval bundle for\nthat dependency larger.","when-to-file-an-issue#When to file an issue":"If none of the above helps, please open an issue with:\nexact @wyw-in-js/* versions,\nbundler/framework + version,\na minimal reproduction (or a small repo),\nlogs with DEBUG=wyw-in-js:* (and slow/dynamic import warnings if applicable)."}}}