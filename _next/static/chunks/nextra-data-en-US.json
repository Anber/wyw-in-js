{"/bundlers/esbuild":{"title":"Usage with esbuild","data":{"installation#Installation":"npm i -D @wyw-in-js/esbuild\npnpm add -D @wyw-in-js/esbuild\nyarn add --dev @wyw-in-js/esbuild\nbun add --dev @wyw-in-js/esbuild","configuration#Configuration":"import wyw from '@wyw-in-js/esbuild';\nimport esbuild from 'esbuild';\nconst prod = process.env.NODE_ENV === 'production';\nesbuild\n  .build({\n    entryPoints: ['src/index.ts'],\n    outdir: 'dist',\n    bundle: true,\n    minify: prod,\n    plugins: [\n      wyw({\n        filter: /\\.(js|jsx|ts|tsx)$/,\n        sourceMap: prod,\n      }),\n    ],\n  })\n  .catch(() => process.exit(1));"}},"/bundlers/rollup":{"title":"Usage with Rollup","data":{"installation#Installation":"To use WyW-in-JS with Rollup, you need to use it together with a plugin which handles CSS files, such as rollup-plugin-css-only:\nnpm i -D rollup-plugin-css-only @wyw-in-js/rollup\npnpm add -D rollup-plugin-css-only @wyw-in-js/rollup\nyarn add --dev rollup-plugin-css-only @wyw-in-js/rollup\nbun add --dev rollup-plugin-css-only @wyw-in-js/rollup","configuration#Configuration":"import wyw from '@wyw-in-js/rollup';\nimport css from 'rollup-plugin-css-only';\nexport default {\n  plugins: [\n    wyw({\n      sourceMap: process.env.NODE_ENV !== 'production',\n    }),\n    css({\n      output: 'styles.css',\n    }),\n  ],\n};\nIf you are using @rollup/plugin-babel as well, ensure the wyw plugin is declared earlier in the plugins array than your babel plugin.\nimport wyw from '@wyw-in-js/rollup';\nimport css from 'rollup-plugin-css-only';\nimport babel from '@rollup/plugin-babel';\nexport default {\n  plugins: [\n    wyw({\n      sourceMap: process.env.NODE_ENV !== 'production',\n    }),\n    css({\n      output: 'styles.css',\n    }),\n    babel({}),\n    /* rest of your plugins */\n  ],\n};"}},"/bundlers/svelte":{"title":"Usage with Svelte","data":{"contents#Contents":"Svelte with Rollup\nSvelte with Webpack","rollup#Rollup":"Take a look: d964432Install rollup-plugin-css-only and update rollup.config.js\nimport svelte from 'rollup-plugin-svelte';\nimport css from 'rollup-plugin-css-only'; // for CSS bundling\nimport wyw from '@wyw-in-js/rollup';\nconst dev = process.env.NODE_ENV !== 'production';\nexport default {\n  ...\n  plugins: [\n    svelte({\n      dev,\n      // allow `plugin-css-only` to bundle with CSS generated by wyw\n      emitCss: true,\n    }),\n    wyw({\n      sourceMap: dev,\n    }),\n    css({\n      output: '<OUT_FOLDER>/bundle.css',\n    }),\n  ],\n};\nIMPORTANT: rollup-plugin-css-only generates incorrect sourcemaps (see thgh/rollup-plugin-css-only#10). Use an alternative CSS plugin such as rollup-plugin-postcss instead in the same way as above.","webpack#Webpack":"Take a look: 5ffd69dUpdate webpack.config.js with the following:\nconst prod = process.env.NODE_ENV === 'production';\nconst wywLoader = {\n  loader: '@wyw-in-js/webpack-loader',\n  options: {\n    sourceMap: !prod,\n  },\n};\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        exclude: /node_modules/,\n        use: [wywLoader],\n      },\n      {\n        test: /\\.svelte$/,\n        use: [\n          wywLoader,\n          {\n            loader: 'svelte-loader',\n            options: {\n              dev: !prod,\n              emitCss: true,\n              hotReload: true,\n            },\n          },\n        ],\n      },\n      ...(CSS rules)\n    ],\n  },\n};"}},"/bundlers/vite":{"title":"Usage with Vite","data":{"installation#Installation":"Since Vite supports Rollup plugin Since Vite provides more features and flexibility, WyW-in-JS has a separate plugin for it @wyw-in-js/vite. Vite handles CSS by itself, you don't need a css plugin.\nnpm i -D @wyw-in-js/vite\npnpm add -D @wyw-in-js/vite\nyarn add --dev @wyw-in-js/vite\nbun add --dev @wyw-in-js/vite","configuration#Configuration":"import { defineConfig } from 'vite';\nimport wyw from '@wyw-in-js/vite';\nexport default defineConfig(() => ({\n  // ...\n  plugins: [wyw()],\n}));\nIf you are using language features that requires a babel transform (such as typescript), ensure the proper babel presets or plugins are passed to wyw.\nimport { defineConfig } from 'vite';\nimport wyw from '@wyw-in-js/vite';\n// example to support typescript syntax:\nexport default defineConfig(() => ({\n  // ...\n  plugins: [\n    wyw({\n      include: ['**/*.{ts,tsx}'],\n      babelOptions: {\n        presets: ['@babel/preset-typescript', '@babel/preset-react'],\n      },\n    }),\n  ],\n}));"}},"/bundlers/webpack":{"title":"Usage with Webpack","data":{"installation#Installation":"npm i -D @wyw-in-js/webpack-loader\npnpm add -D @wyw-in-js/webpack-loader\nyarn add --dev @wyw-in-js/webpack-loader\nbun add --dev @wyw-in-js/webpack-loader","configuration#Configuration":"module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js/,\n        use: [{ loader: '@wyw-in-js/webpack-loader' }],\n      },\n    ],\n  },\n};"}},"/changelog":{"title":"Changelog","data":{}},"/":{"title":"Index","data":{}},"/configuration":{"title":"Configuration","data":{"":"WyW-in-JS can be customized using a JavaScript, JSON or YAML file. This can be in form of:\nwyw-in-js.config.js JS file exporting the object (recommended).\nwyw-in-js property in a package.json file.\n.wyw-in-jsrc file with JSON or YAML syntax.\n.wyw-in-jsrc.json, .wyw-in-jsrc.yaml, .wyw-in-jsrc.yml, or .wyw-in-jsrc.js file.\nExample wyw-in-js.config.js:\nmodule.exports = {\n  evaluate: true,\n  displayName: false,\n};","options#Options":"evaluate: boolean (default: true):Enabling this will evaluate dynamic expressions in the CSS. You need to enable this if you want to use imported variables in the CSS or interpolate other components. Enabling this also ensures that your styled components wrapping other styled components will have the correct specificity and override styles properly.\ndisplayName: boolean (default: false):Enabling this will add a display name to generated class names, e.g. .Title_abcdef instead of `.abcdef'. It is disabled by default to generate smaller CSS files.\nvariableNameConfig: \"var\" | \"dashes\" | \"raw\" (default: var):Configures how the variable will be formatted in final CSS.Possible values\nvarUse full css variable structure. This is default behavior.\nimport { styled } from '@linaria/react';\nexport const MyComponent = styled.div`\n  color: ${(props) => props.color};\n`;\nIn CSS you will see full variable declaration\n.MyComponent_m1cus5as {\n  color: var(--m1cus5as-0);\n}\ndashesRemoves var() around the variable name. It is useful when you want to control the variable on your own. For example you can set default value for CSS variable.\nimport { styled } from '@linaria/react';\nexport const Theme = styled.div`\n  --font-color: red;\n`;\nexport const MyComponent = styled.div`\n  // Returning empty string is mandatory\n  // Otherwise you will have \"undefined\" in css variable value\n  color: var(${(props) => props.color ?? ''}, var(--font-color));\n`;\nfunction App() {\n  return (\n    <Theme>\n      <MyComponent>Text with red color</MyComponent>\n      <MyComponent color=\"blue\">Text with blue color</MyComponent>\n    </Theme>\n  );\n}\nIn CSS you will see generated variable name and your default value.\n.Theme_t1cus5as {\n  --font-color: red;\n}\n.MyComponent_mc195ga {\n  color: var(--mc195ga-0, var(--font-color));\n}\nrawUse only variable name without dashes and var() wrapper.\nimport { styled } from '@linaria/react';\nexport const MyComponent = styled.div`\n  color: ${(props) => props.color};\n`;\nIn CSS you will see just the variable name. This is not valid value for css property.\n.MyComponent_mc195ga {\n  color: mc195ga-0;\n}\nYou will have to make it valid:\nexport const MyComponent = styled.div`\n  color: var(--${(props) => props.color});\n`;\nclassNameSlug: string | ((hash: string, title: string, args: ClassNameSlugVars) => string) (default: default):Using this will provide an interface to customize the output of the CSS class name. Example:\nclassNameSlug: '[title]',\nWould generate a class name such as .header instead of the default .header_absdjfsdf which includes a hash.You may also use a function to define the slug. The function will be evaluated at build time and must return a string:\nclassNameSlug: (hash, title) => `${hash}__${7 * 6}__${title}`,\nWould generate the class name .absdjfsdf__42__header.Last argument args is an object that contains following properties: title, hash, index, dir, ext, file, name. These properties\nare useful when you want to generate your own hash:\nconst sha1 = require('sha1');\nmodule.exports = {\n  classNameSlug: (hash, title, args) => sha1(`${args.name}-${title}`),\n};\nnote invalid characters will be replaced with an underscore (_).Variables\nhash: The hash of the content.\ntitle: The name of the class.\nvariableNameSlug: string | ((context: IVariableContext) => string) (default: default):Using this will provide an interface to customize the output of the CSS variable name. Example:\nvariableNameSlug: '[componentName]-[valueSlug]-[index]',\nWould generate a variable name such as --Title-absdjfsdf-0 instead of the @react/styled's default --absdjfsdf-0.You may also use a function to define the slug. The function will be evaluated at build time and must return a string:\nvariableNameSlug: (context) => `${context.valueSlug}__${context.componentName}__${context.precedingCss.match(/([\\w-]+)\\s*:\\s*$/)[1]}`,\nWould generate the variable name --absdjfsdf__Title__flex-direction.note invalid characters will be replaced with an underscore (_).Variables\ncomponentName - the displayName of the component.\ncomponentSlug - the component slug.\nindex - the index of the css variable in the current component.\nprecedingCss - the preceding part of the css for the variable, i.e. flex: 1; flex-direction: .\npreprocessor - the preprocessor used to process the tag (e.g. 'StyledProcessor' or 'AtomicStyledProcessor').\nsource - the string source of the css property value.\nunit - the unit.\nvalueSlug - the value slug.\noverrideContext: (context: Partial<vm.Context>, filename: string) => Partial<vm.Context>A custom function to override the context used to evaluate modules. This can be used to add custom globals or override the default ones.\nmodule.exports = {\n  overrideContext: (context, filename) => ({\n    ...context,\n    HighLevelAPI: () => \"I'm a high level API\",\n  }),\n};\nrules: EvalRule[]The set of rules that defines how the matched files will be transformed during the evaluation.\nEvalRule is an object with two fields:\ntest is a regular expression or a function (path: string) => boolean;\naction is an Evaluator function, \"ignore\" or a name of the module that exports Evaluator function as a default export.\nIf test is omitted, the rule is applicable for all the files.The last matched rule is used for transformation. If the last matched action for a file is \"ignore\" the file will be evaluated as is, so that file must not contain any js code that cannot be executed in nodejs environment (it's usually true for any lib in node_modules).If you need to compile certain modules under /node_modules/ (which can be the case in monorepo projects), it's recommended to do it on a module by module basis for faster transforms, e.g. ignore: /node_modules[\\/\\\\](?!some-module|other-module)/. Example is using Regular Expressions negative lookahead.The Information about Evaluator, its default setting and custom implementations can be founded it evaluators section of How it works docsThe default setup is:\nimport { shaker } from '@wyw-in-js/transform';\n[\n  {\n    action: shaker,\n  },\n  {\n    test: /[\\\\/]node_modules[\\\\/]/,\n    action: 'ignore',\n  },\n  {\n    test: (filename, code) => {\n      if (!/[\\\\/]node_modules[\\\\/]/.test(filename)) {\n        return false;\n      }\n      return /(?:^|\\*\\/|;|})\\s*(?:export|import)[\\s{]/m.test(code);\n    },\n    action: shaker,\n  },\n];\ntagResolver: (source, tag) => stringA custom function to use when resolving template tags.By default, linaria APIs like css and styled must be imported directly from the package – this is because babel needs to be able to recognize the API's to do static style extraction. tagResolver allows css and styled APIs to be imported from other files too.tagResolver takes the path for the source module (eg. @linaria/core) and the name of imported tag (eg. css), and returns the full path to the related processor. If tagResolver returns null, the default tag processor will be used.For example, we can use this to map @linaria/core , @linaria/react or @linaria/atomic where we re-export the module.\n{\n  tagResolver: (source, tag) => {\n    const pathToLocalFile = join(__dirname, './my-local-folder/linaria.js');\n    if (source === pathToLocalFile) {\n      if (tag === 'css') {\n        return require.resolve('@linaria/core/processors/css');\n      }\n      if (tag === 'styled') {\n        return require.resolve('@linaria/react/processors/styled');\n      }\n    }\n    return null;\n  };\n}\nWe can then re-export and use linaria API's from ./my-local-folder:\n// my-file.js\nimport { css, styled } from './my-local-folder/linaria';\nexport const MyComponent = styled.div`\n  color: red;\n`;\nexport default css`\n  border: 1px solid black;\n`;\n// ./my-local-folder/core.js\nexport * from '@linaria/core';\nbabelOptions: ObjectIf you need to specify custom babel configuration, you can pass them here. These babel options will be used by Linaria when parsing and evaluating modules.\nfeatures: Record<string, FeatureFlag>A map of feature flags to enable/disable. See Feature Flags for more information.\ncodeRemover: CodeRemoverOptionsAn object with two keys componentTypes and hocs. Specifies types of variables and HOCs that will be replaced with an empty function before evaluation.\n{\n  codeRemover: {\n    componentTypes: {\n      react: ['FC', 'FunctionComponent', 'ExoticComponent'],\n      preact: ['FunctionComponent'],\n    },\n    hocs: {\n      redux: ['connect'],\n    },\n  },\n}","wyw-in-jsbabel-preset#@wyw-in-js/babel-preset":"The preset pre-processes and evaluates the CSS. The bundler plugins use this preset under the hood. You also might want to use this preset if you import the components outside of the files handled by your bundler, such as on your server or in unit tests.To use this preset, add @wyw-in-js/babel-preset to your Babel configuration at the end of the presets list:.babelrc:\n{\n  \"presets\": [\n    \"@babel/preset-env\",\n    \"@babel/preset-react\",\n+   \"@wyw-in-js\"\n  ]\n}\nThe babel preset can accept the same options supported by the configuration file, however it's recommended to use the configuration file directly."}},"/feature-flags":{"title":"Feature Flags","data":{"":"Feature flags are used to enable or disable specific features provided. The features option in the configuration allows you to control the availability of these features.","syntax-for-specifying-flags#Syntax for Specifying Flags":"true: Enables the feature for all files.\nfalse: Disables the feature for all files.\n\"glob\": Enables the feature only for files that match the specified glob pattern.\n[\"glob1\", \"glob2\"]: Enables the feature for files matching any of the specified glob patterns.\n[\"glob1\", \"!glob2\"]: Enables the feature for files matching glob1 but excludes files that match glob2.\nThe dangerousCodeRemover is a flag that is enabled by default. It is designed to enhance the static evaluation of values that are interpolated in styles and to optimize the processing of styled-wrapped components during the build stage. This optimization is crucial for maintaining a stable and fast build process. It is important to note that the dangerousCodeRemover does not impact the runtime code; it solely focuses on the code used during the build.","how-it-works#How It Works":"During the build process, WyW-in-JS statically analyzes the CSS-in-JS codebase and evaluates the styles and values that are being interpolated. The dangerousCodeRemover steps in at this stage to remove potentially unsafe code, which includes code that might interact with browser-specific APIs, make HTTP requests, or perform other runtime-specific operations. By removing such code, the evaluation becomes more reliable, predictable, and efficient.","benefits#Benefits":"Enabling the dangerousCodeRemover feature provides several benefits:\nStability: The removal of potentially unsafe code ensures that the build process remains stable. It minimizes the chances of encountering build-time errors caused by unsupported browser APIs or non-static operations.\nPerformance: Removing unnecessary code results in faster build times. The build tool can efficiently process and evaluate the styles and components without unnecessary overhead, leading to quicker development cycles.","fine-tuning-the-removal#Fine-Tuning the Removal":"While the dangerousCodeRemover is highly effective at optimizing the build process, there may be cases where it becomes overly aggressive and removes code that is actually required for your specific use case. In such situations, you have the flexibility to fine-tune the behavior of the remover.By leveraging the features option in the configuration, you can selectively disable the dangerousCodeRemover for specific files. This allows you to preserve valuable code that may not be safely evaluated during the build process.","example#Example":"Suppose you have a file named specialComponent.js that contains code that should not be deleted. By adding the following entry to your features configuration:\n{\n  features: {\n    dangerousCodeRemover: [\"**/*\", \"!**/specialComponent.js\"],\n  },\n}\nYou are instructing WyW-in-JS to exclude the specialComponent.js file from the removal process. As a result, any code within this file that would have been removed by the dangerousCodeRemover will be retained in the build output.The globalCache is enabled by default. WyW-in-JS uses two levels of caching to improve the performance of the build process. The first level is used to cache transformation and evaluation results for each transform call, usually a single call of Webpack's loader or Vite's transform hook. The second level is used to cache the results of the entire build process. The globalCache feature controls the second level of caching. Turning off this feature will result in a slower build process but decreased memory usage.The happyDOM is enabled by default. This feature enables usage of https://github.com/capricorn86/happy-dom to emulate a browser environment during the build process. Typically, the dangerousCodeRemover feature should remove all browser-related code. However, some libraries may still contain browser-specific code that cannot be statically evaluated. In such cases, the happyDOM feature can be used to emulate a browser environment during the build process. This allows WyW-in-JS to evaluate the code without encountering errors caused by missing browser APIs.The softErrors is disabled by default. It is designed to provide a more lenient evaluation of styles and values that are interpolated in styles. This flag is useful for debugging and prevents the build from failing even if some files cannot be processed with WyW-in-JS.The useBabelConfigs feature is enabled by default. If it is enabled, WyW-in-JS will try to resolve the .babelrc file for each processed file. Otherwise, it will use the default Babel configuration from babelOptions in the configuration.Please note that the default value of useBabelConfigs will be changed to false in the next major release."}},"/how-it-works":{"title":"How it works?","data":{"":"wyw-in-js creates an entrypoint for each file to process, and transforms this entrypoint by running the workflow action.","entrypoint#Entrypoint":"We runs the worlflow action with actionRunner and actionsCache for better performance by avoiding running the same action twice. A workflow contains the following nested actions:\nworkflow\n├── processEntrypoint\n│   ├── explodeReexports\n│   │   ├── resolveImports\n│   │   └── getExports\n│   │       └── resolveImports\n│   └── transform\n│       ├── resolveImports\n│       └── processImports\n├── evalFile\n├── collect\n└── extract","workflow-action#Workflow Action":"The entry point for file processing. Sequentially calls processEntrypoint, evalFile, collect, and extract. Returns the result of transforming the source code as well as all artifacts obtained from code execution.","input#Input":"import { css } from '@foooo/processor'; /* Your processor */\nimport { getColor } from './get-color';\nexport const c1 = css`\n  background-color: ${getColor('hawk')};\n  color: ${({ theme }) => theme.palette.primary.main};\n  font-size: ${({ theme }) => theme.size.font.h1};\n`;\nexport const c2 = css(({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n}));\n/* usually defined in your processor, will be used when we're building the processor */\nexport const theme = {\n  palette: {\n    primary: {\n      main: 'red',\n    },\n    error: {\n      main: 'orange',\n    },\n  },\n  size: {\n    font: {\n      h1: '3rem',\n      h2: '2.2rem',\n    },\n  },\n};\n// ./get-color.js\nexport const getColor = (variant) => {\n  if (variant === 'hawk') {\n    return 'pink';\n  }\n  if (variant === 'wild') {\n    return 'purple';\n  }\n  if (variant === 'king') {\n    return 'green';\n  }\n  return 'white';\n};","output#Output":"The output can be different depending on the implementation of your processor!\nconst c1 = 'abcd';\nconst c2 = 'wxyz';\n.abcd {\n  background-color: pink;\n  color: red;\n  font-size: 3rem;\n}\n.wxyz {\n  background-color: purple;\n  color: orange;\n  font-size: 2.2rem;\n}","processentrypoint-action#ProcessEntrypoint Action":"The first stage of processing an entrypoint. This stage is responsible for:\nscheduling the explodeReexports action\nscheduling the transform action\nrescheduling itself if the entrypoint is superseded","explodereexports-action#ExplodeReexports Action":"Replaces wildcard reexports with named reexports. Recursively emits getExports for each reexported module, and replaces wildcard with resolved named.","input-1#Input":"export * from './foo'; /* wildcard reexports */\n// ./foo.js\nexport const foo1 = 'foo1';\nexport const foo2 = 'foo2';\nexport const foo3 = 'foo3';","output-1#Output":"export { foo1, foo2, foo3 } from './foo';","resolveimports-action#ResolveImports Action":"Resolves specified imports with a provided resolver.","getexports-action#GetExports Action":"Collects exports and re-exports. Recursively emits getExports for each reexported module.\n// index.js\nexport * from 'a'; /* wildcard re-export, emit getExports for 'a' */\n// a.js\nexport * from 'b'; /* wildcard re-export, emit getExports for 'b' */\n// b.js\nexport * from 'c'; /* wildcard re-export, emit getExports for 'c' */\n// c.js\nexport const c = 'c';","transform-action#Transform Action":"Prepares the code for evaluation. This includes removing dead and potentially unsafe code. Emits resolveImports and processImports events.","transform-preeval#Transform Preeval":"Finds the defined processors along with their usages.\nimport { /* defined processor */ css } from '@foooo/processor';\nimport { getColor } from './get-color';\nexport const c1 = /* first usage */ css`\n  background-color: ${getColor('hawk')};\n  color: ${({ theme }) => theme.palette.primary.main};\n  font-size: ${({ theme }) => theme.size.font.h1};\n`;\nexport const c2 = /* second usage */ css(({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n}));\nAfter all usages are found, we extract the expression for each usage. The extracted expressions _exp, _exp2, _exp3 and _exp4 will be inserted as close as possible before its usage.\nimport { css } from '@foooo/processor';\nimport { getColor } from './get-color';\nconst _exp = () => getColor('hawk');\nconst _exp2 = () => ({ theme }) => theme.palette.primary.main;\nconst _exp3 = () => ({ theme }) => theme.size.font.h1;\nexport const c1 = css`\n  background-color: ${getColor('hawk')};\n  color: ${({ theme }) => theme.palette.primary.main};\n  font-size: ${({ theme }) => theme.size.font.h1};\n`;\nconst _exp4 = () => ({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n});\nexport const c2 = css(({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n}));\nEach usage requires one processor instance for processing. In this case, we have two processor instance.Assume the first css processor has className = 'abcd' and dependencies = [_exp, _exp2, _exp3], second css processor has className = 'wxyz' and dependencies = [_exp4]. After the preeval stage:\nimport { css } from '@foooo/processor';\nimport { getColor } from './get-color';\nconst _exp = () => getColor('hawk');\nconst _exp2 = () => ({ theme }) => theme.palette.primary.main;\nconst _exp3 = () => ({ theme }) => theme.size.font.h1;\nexport const c1 = 'abcd'; /* do evaltime replacement */\nconst _exp4 = () => ({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n});\nexport const c2 = 'wxyz'; /* do evaltime replacement */\nexport const __wywPreval = { /* collect all dependencies in this object */\n  _exp: _exp,\n  _exp2: _exp2,\n  _exp3: _exp3,\n  _exp4: _exp4\n};","transform-evaluator#Transform Evaluator":"Finds all irrelevant code and cuts it out of the file. We use the shaker plugin by default. For the root entrypoint, we only care about the __wywPreval named export. For child entrypoints like the one for get-color.js in our example, all its code will be shaked out except for the getColor named export and its dependencies.","processimports-action#ProcessImports Action":"Creates new entrypoints and emits processEntrypoint for each resolved import. In our example, we create a child entrypoint for the get-color module to process getColor.\nimport { css } from '@foooo/processor';\nimport { getColor } from './get-color'; /* child entrypoint with only=['getColor'] */\nconst _exp = () => getColor('hawk');\n// ...","evalfile-action#EvalFile Action":"Executes the code prepared in previous steps, the processEntrypoint action, within the current Entrypoint. Returns all exports that were requested in only.In this step, we create Module for each entrypoint and evaluate each module recursively with node:vm. After all modules are evaluated, we execute the extracted expressions _exp, _exp2, _exp3 and _exp4 which are extracted in Transform Preeval step.\nconst _exp = () => getColor('hawk');\nconst _exp2 = () => ({ theme }) => theme.palette.primary.main;\nconst _exp3 = () => ({ theme }) => theme.size.font.h1;\nconst _exp4 = () => ({ theme }) => ({\n  backgroundColor: getColor('wild'),\n  color: theme.palette.error.main,\n  fontSize: theme.size.font.h2,\n});\nNow we have a valueCache map for building our processor instances of this entrypoint in next step.\nconst valueCache = new Map([\n  ['_exp', 'pink'],\n  ['_exp2', [Function]], /* ({ theme }) => theme.palette.primary.main */\n  ['_exp3', [Function]], /* ({ theme }) => theme.size.font.h1 */\n  ['_exp4', [Function]], /* ({ thene }) => ({ backgroundColor: getColor('wild'), ... }) */\n])","collect-action#Collect Action":"Builds and does runtime replacement for each processor. Removes __wywPreval object and all related code.Collect action calls processor.build with valueCache as the argument. You can decide how to build the artifacts. Here is a simple example:\nexport default class CssProcessor extends BaseProcessor {\n  // ...\n  build(values: Map<string, unknown>) {\n    let cssText = '';\n    const props = { theme };\n    if (this.callParam[0] === 'template') {\n      this.callParam[1].forEach((item: any) => {\n        if ('kind' in item) {\n          const evaluatedValue = values.get(item.ex.name);\n          cssText +=\n            typeof evaluatedValue === 'function'\n              ? evaluatedValue(props)\n              : evaluatedValue;\n        } else {\n          cssText += item.value.cooked;\n        }\n      });\n    } else if (this.callParam[0] === 'call') {\n      const evaluatedValue = values.get(this.callParam[1].ex.name) as Function;\n      const obj = evaluatedValue(props);\n      cssText += '\\n';\n      Object.entries(obj).forEach(([key, value]) => {\n        cssText += `  ${toKebabCase(key)}: ${value};\\n`;\n      });\n    }\n    this.artifacts.push([\n      'css',\n      [\n        /* Rules */\n        {\n          [this.adSelector]: {\n            className: this.className,\n            cssText,\n            // ...\n          },\n        },\n        /* Replacements */\n        [\n          // ...\n        ],\n      ],\n    ]);\n  }\n  // ...\n}\nThe artifacts of our first processor:\n[\n  'css',\n  {\n    '.abcd': {\n      className: 'abcd',\n      cssText: '\\n  background-color: pink;\\n  color: red;\\n  font-size: 3rem;\\n',\n      // ...\n    },\n  },\n  [\n    // ...\n  ],\n];\nThe second processor:\n[\n  'css',\n  {\n    '.wxyz': {\n      className: 'wxyz',\n      cssText: '\\n  background-color: purple;\\n  color: orange;\\n  font-size: 2.2rem;\\n',\n      // ...\n    },\n  },\n  [\n    // ...\n  ],\n];\nAnd after the code removal, our remaining code becomes:\nconst c1 = 'abcd';\nconst c2 = 'wxyz';","extract-action#Extract Action":"Extracts artifacts (e.g. CSS) from processors."}},"/how-to/custom-tagged-template":{"title":"Creating Custom Tagged Template Processors","data":{"":"In the wyw-in-js toolkit, you can create custom processors for handling tagged templates. This guide will walk you through the process of creating custom tagged template processors.","overview#Overview":"A tagged template processor is a class that extends the TaggedTemplateProcessor class from the @wyw-in-js/processor-utils package. This class provides a set of methods and properties that you can override to customize the behavior of the processor.","creating-a-processor#Creating a Processor":"To create a processor, you need to define a class that extends TaggedTemplateProcessor. The constructor of your class should call the super method with the appropriate parameters.\nimport { TaggedTemplateProcessor } from '@wyw-in-js/processor-utils';\nexport default class MyProcessor extends TaggedTemplateProcessor {\n  constructor(params: Params, ...args: TailProcessorParams) {\n    super(params, ...args);\n  }\n}\nThe Params type is an array of Param types, which represent the different ways a custom processor can be called. Each Param type corresponds to a different call pattern:\nCalleeParam: This represents a call where the processor is directly invoked with a template literal, like css``. The first element of the array is the string 'callee', and the second element is an Identifier or MemberExpression, which represents the processor being called (e.g., css).\nCallParam: This represents a call where the processor is invoked with a function call, like styled(SomeTag)``. The first element of the array is the string 'call', and the rest of the elements are ExpressionValues, which represent the arguments passed to the function call.\nMemberParam: This represents a call where the processor is invoked on a member, like styled.div``. The first element of the array is the string 'member', and the second element is a string, which represents the member being accessed (e.g., 'div').\nTemplateParam: This represents a call where the processor is invoked with a template literal, like styled``. The first element of the array is the string 'template', and the second element is an array of TemplateElements or ExpressionValues, which represent the contents of the template literal.\nIn summary, the Params type is used to capture the different ways a custom processor can be invoked, and the specific arguments or members used in the invocation.The styled.div call with a template literal color: red would be represented in the Params type as follows:\nconst params: Params = [\n  ['callee', { /* Identifier or MemberExpression representing 'styled' */ }],\n  ['member', 'div'],\n  ['template', [\n    { /* TemplateElement representing 'color: red' */ }\n  ]]\n];\nIn this example:\nThe first element of the Params array is a CalleeParam representing the styled function.\nThe second element is a MemberParam representing the div member of the styled object.\nThe third element is a TemplateParam representing the template literal color: red.\nThe actual Identifier, MemberExpression, and TemplateElement instances would be generated by a parser like Babel when parsing the source code.","isvalidparams#isValidParams":"The isValidParams function is a type guard that checks if the provided params array matches the structure defined by the constraints array. It returns a boolean indicating whether the params array is valid according to the constraints.The constraints array is an array of ParamConstraint types, which can be a ParamName (i.e., 'callee', 'call', 'member', 'template'), an array of ParamName, or a wildcard '*'. The '...' in the constraints array indicates that any number of any type of params can follow.The function iterates over the params and constraints arrays simultaneously. If it encounters a '...' in the constraints, it immediately returns true, as '...' allows any number of any params. If it encounters a '*', it checks if the corresponding param is defined. If it is not, it returns false. If the constraint is an array, it checks if the param's type is in the array. If it is not, it returns false. If the constraint is a ParamName, it checks if the param's type matches the ParamName. If it does not, it returns false.If the function iterates over all the params and constraints without returning false, it returns true, indicating that the params array is valid according to the constraints.","overriding-methods#Overriding Methods":"The TaggedTemplateProcessor class provides several methods that you can override to customize the behavior of your processor.","get-asselector#get asSelector()":"This getter should return a string that represents the CSS selector for the styles defined in the tagged template.","get-value#get value()":"This getter should return an Expression that represents the value of the tagged template. This value will replace the tagged template at runtime.For simple cases like css, it is just a string literal with a class name. For styled, it is an object with some metadata, such as the class name and information about extending.Here is an example of how the value getter might be implemented in a class that extends TaggedTemplateProcessor:\npublic override get value(): ObjectExpression {\n  const t = this.astService;\n  return t.objectExpression([\n    t.objectProperty(\n      t.stringLiteral('className'),\n      t.stringLiteral(this.className)\n    ),\n    t.objectProperty(\n      t.stringLiteral('extends'),\n      this.extendsNode\n        ? t.callExpression(t.identifier(this.extendsNode), [])\n        : t.nullLiteral()\n    ),\n  ]);\n}\nIn this example, the value getter returns an ObjectExpression that includes the class name and information about extending. The extendsNode is a hypothetical property that represents the node that the current node extends. If extendsNode is not defined, a nullLiteral is returned.","addinterpolationnode-expression-precedingcss-string-source-string-unit--#addInterpolation(node: Expression, precedingCss: string, source: string, unit = '')":"This method is called when an interpolation is found in the tagged template. It should return a string that represents the identifier of the interpolation.","doevaltimereplacement#doEvaltimeReplacement()":"This method is called during the evaluation phase. It should replace the tagged template with the appropriate value.","doruntimereplacement#doRuntimeReplacement()":"This method is called during the runtime phase. It should replace the tagged template with the appropriate value.","extractrulesvaluecache-valuecache-csstext-string-loc-sourcelocation--null#extractRules(valueCache: ValueCache, cssText: string, loc?: SourceLocation | null)":"This method is called to extract the CSS rules from the tagged template. It should return an object that represents the CSS rules.","tostring#toString()":"This method should return a string that represents the source code of the tagged template.","example#Example":"Here is an example of a custom processor that handles styled tagged templates:\nimport { TaggedTemplateProcessor, validateParams } from '@wyw-in-js/processor-utils';\nimport type { Params, TailProcessorParams } from '@wyw-in-js/processor-utils';\nexport default class StyledProcessor extends TaggedTemplateProcessor {\n  constructor(params: Params, ...args: TailProcessorParams) {\n    validateParams(params, ['callee', '*', '...'], TaggedTemplateProcessor.SKIP);\n    super(params, ...args);\n  }\n  public override get asSelector(): string {\n    return `.${this.className}`;\n  }\n  // ... other methods\n}\nIn this example, the StyledProcessor class extends TaggedTemplateProcessor and overrides several methods to handle styled tagged templates. The asSelector getter returns a CSS class selector based on the className property of the processor.Please refer to the css.ts and styled.ts files for more detailed examples of custom processors."}}}